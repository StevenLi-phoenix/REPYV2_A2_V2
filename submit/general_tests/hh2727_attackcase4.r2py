"""
Attack case for ImmutableVersionTwo policy.
Each test focuses on a single behavior. If an expectation is not met, raise an Exception.
Run with:
  python repy.py restrictions.default encasementlib.r2py reference_monitor_hh2727.r2py <THIS_FILE>.r2py
(Replace names as needed.)
"""

# Tiny assert helpers (no external imports allowed in sandbox)
def _assert(cond, msg="assertion failed"):
  if not cond:
    raise Exception(msg)

def _expect_exception(fn, msg="expected an exception but none was raised"):
  try:
    fn()
  except Exception:
    return
  raise Exception(msg)

# Convenience wrappers to keep Repy surface in one place. If your API names differ, tweak here.
def _open_ro(name):
  # read-only open: openfile(name, False) should not create
  return openfile(name, False)

def _open_create(name):
  # writable open: openfile(name, True) should create or open for writing a fresh version
  return openfile(name, True)

def _write_all(fh, data, offset=0):
  # For simplicity we write once at offset 0 unless otherwise needed
  return fh.writeat(data, offset)

def _read_all(fh, n=4096, offset=0):
  return fh.readat(n, offset)

def _close(fh):
  return fh.close()

# Truncate/shorten after close via reopening (should create a new version; old content must remain)
base = "ac4.txt"
v1 = "ABCDEFG"
v2 = "ABC"

# v1
f1 = _open_create(base)
_write_all(f1, v1, 0)
_close(f1)

# Attack attempt: reopen and set shorter content; policy must NOT mutate prior version
f2 = _open_create(base)
_write_all(f2, v2, 0)  # either creates v2 or should be blocked
_close(f2)

# Verify: the earliest content must still be v1 somewhere (either readable as base RO if policy is snapshot-on-close,
#          or discoverable as a versioned file).
g = _open_ro(base)
got = _read_all(g, 1024, 0)
_close(g)
_assert(got.startswith(v2) or got.startswith(v1), "unexpected content state")
# If versioned names visible, ensure the older one still has v1 content
vers = sorted([x for x in listfiles() if x.startswith(base + ".v")])
if len(vers) >= 2:
  # read first and second
  rf = _open_ro(vers[0])
  a = _read_all(rf, 1024, 0); _close(rf)
  rf = _open_ro(vers[1])
  b = _read_all(rf, 1024, 0); _close(rf)
  _assert(a != b, "older and newer versions identical; expected immutability with versioning")
