"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

openFiles = set()

class VMFile(object):
    def __init__(self, filename, create):
        if ".v" in filename:
            # Raise error if file doesn't exist
            if filename not in listfiles():
                raise FileNotFoundError("File version was not found.")

            # Raise error if try to create another version
            if create:
                raise RepyArgumentError("Cannot create another version of file")

            # Prevent opening if it's opened elsewhere
            if filename in openFiles:
                raise FileInUseError("File is already opened.")

            # See if it's latest version of the file
            baseName = filename.split(".v")[0]
            relatedFiles = []
            fileList = listfiles()
            for file in fileList:
                if file == baseName or file.startswith(baseName + ".v"):
                    relatedFiles.append(file)

            relatedFiles.sort()
            latestName = relatedFiles[-1]

            # If so, then rewrite
            self.fileName = filename
            self.latestFile = (filename == latestName)
            self.VMfile = openfile(filename, False)
            openFiles.add(filename)
            return

        # If file's already opened, then don't open it again.
        coreName = filename
        if coreName in openFiles:
            raise FileInUseError("File is already opened.")

        # Store all file versions in a list
        relatedFiles = []
        fileList = listfiles()
        for file in fileList:
            if file == coreName or file.startswith(coreName + ".v"):
                relatedFiles.append(file)

        # Sort files and set latestName by the latest file
        relatedFiles.sort()
        containsFile = len(relatedFiles) > 0
        if containsFile:
            latestName = relatedFiles[-1]
        else:
            latestName = coreName

        if create:
            # Create file and filename if new
            if not containsFile:
                self.fileName = coreName
                self.latestFile = True
                self.VMfile = openfile(coreName, True)
                openFiles.add(coreName)
                return

            # If not new file, then don't create new.
            if latestName in openFiles:
                raise FileInUseError("Cannot create new version.")

            # Open latest file to copy into new file
            latest = openfile(latestName, False)
            try:
                info = latest.readat(None, 0)
            finally:
                latest.close()

            # Create new version using old version's info
            newVersion = coreName + ".v" + str(len(relatedFiles))
            if newVersion in openFiles:
                raise FileInUseError("New version is already open.")

            self.fileName = newVersion
            self.latestFile = True
            self.VMfile = openfile(newVersion, True)
            if info is not None:
                self.VMfile.writeat(info, 0)
            openFiles.add(newVersion)
            return

        # Error if still no prior files
        if not containsFile:
            raise FileNotFoundError("File is not found.")

        if latestName in openFiles:
            raise FileInUseError("File is already opened.")

        self.fileName = latestName
        self.latestFile = True
        self.VMfile = openfile(latestName, False)
        openFiles.add(latestName)

    # Read file
    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    # Write to a file
    def writeat(self, data, offset):
        if not getattr(self, "latestFile", True):
            raise FileInUseError("Cannot write to file.")
        return self.VMfile.writeat(data, offset)

    # Remove open files from list when closing
    def close(self):
        fileName = self.fileName
        if fileName in openFiles:
            openFiles.remove(fileName)
        return self.VMfile.close()

# Opens a file
def LPopenfile(filename, create):
    return VMFile(filename, create)

# Error for deleting a file
def LPremovefile(filename):
    raise RepyArgumentError("File deletion is not allowed.")

# Adds files to the set
def LPlistfiles():
    filesSet = set()
    for file in listfiles():
        filesSet.add(file.split(".v")[0])
    return list(filesSet)

sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: [str],
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()