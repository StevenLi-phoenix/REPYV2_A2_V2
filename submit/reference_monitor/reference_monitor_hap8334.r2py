"""
reference_monitor_hap8334.r2py
"""

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"



# ---------------------------------------------------------------------

lock_file = []
def sani_sep(filename, arg):
    if not isinstance(filename, str):
        if arg == 1: return False
        elif arg == 2: return filename
        elif arg == 3: return 0
        return None

    parts = filename.rsplit(".v", 1) # Split version and base
    if len(parts) != 2: # base file
        if arg == 1: return False
        elif arg == 2: return filename
        elif arg == 3: return 0
        return None

    base, ver = parts
    if base == "" or ver == "" or not ver.isdigit(): # Checking empty value of base or version, also ver is digit or not.
        if arg == 1: return False
        elif arg == 2: return filename
        elif arg == 3: return True
        return None

    if int(ver) < 1: # Checking is version is less than 1 or not
        if arg == 1: return False
        elif arg == 2: return filename
        elif arg == 3: return True
        return None

    # Lastly, successful sanitation result
    if arg == 1: return True
    elif arg == 2: return base
    elif arg == 3:return int(ver)
    return None


# ---------------------------------------------------------------------
class VMFile():
    def __init__(self, filename, create, result, read=False):
        self.filename = filename
        self.VMfile = result
        self.read = read

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self.read:
             raise FileInUseError("Cannot write to read-only file")

        token = self.filename + ".lock"
        if token not in lock_file:
            raise FileInUseError("File not open for writing")

        if sani_sep(self.filename, 1):
             base = sani_sep(self.filename, 2)
             my_ver = sani_sep(self.filename, 3)

        else:
            base = sani_sep(self.filename, 2)
            my_ver = 0

        max_ver = 0
        for f in listfiles():
            if sani_sep(f, 1):
                fbase = sani_sep(f, 2)
                fver = sani_sep(f, 3)
                if fbase == base and isinstance(fver, int) and fver > max_ver:
                    max_ver = fver
            else:
                if f == base:
                    # base exists -> version 0
                    max_ver = max(max_ver, 0)

        if my_ver != max_ver:
            raise FileInUseError("Cannot write to older version (immutable).")

        return self.VMfile.writeat(data, offset)

    def close(self):
        token = self.filename + ".lock"
        if token in lock_file:
            try:
                lock_file.remove(token)
            except ValueError:
                pass
        return self.VMfile.close()


# ---------------------------------------------------------------------
def LPopenfile(filename, create):
    if not isinstance(filename, str):
        raise RepyArgumentError("Filename must be a string")

    if create and sani_sep(filename, 3): # Create = True, with explicit version name REJECTED
        raise RepyArgumentError("Cannot create explicit version files")

    # CASE 1: Create = False, open existing file or its version
    if not create:
        if filename not in listfiles():
            raise FileNotFoundError("No such file or version")

        if filename + ".lock" in lock_file:
            raise FileInUseError("File already open")

        res = openfile(filename, False)

        if sani_sep(filename, 1):
            return VMFile(filename, False, res, read=True)

        else:
            lock_file.append(filename + ".lock")
            return VMFile(filename, False, res, read=False)


    # CASE 2: Create = True, base file does not exist. Hence, create new base
    base = sani_sep(filename, 2)
    if create and base not in listfiles():
        res = openfile(base, True)
        lock_file.append(base + ".lock")
        return VMFile(base, True, res, read=False)


    # CASE 3: Create = True, base exist. Hence, create new version.
    max_ver = 0
    for i in listfiles():
        if sani_sep(i, 1):
            i_base = sani_sep(i, 2)
            i_ver = sani_sep(i, 3)
            if i_base == base and isinstance(i_ver, int) and i_ver > max_ver:
                max_ver = i_ver
        else:
            if i == base:
                max_ver = max(max_ver, 0)

    if max_ver == 0:
        latest_name = base
    else:
        latest_name = base + ".v" + str(max_ver)

    if latest_name + ".lock" in lock_file:
        raise FileInUseError("Cannot create new version while latest version is open")

    # Read previous version content
    prev_file = openfile(latest_name, False)
    try:
        content = []
        offset = 0
        while True:
            chunk = prev_file.readat(512, offset)
	    if not chunk:
		break
	    content.append(chunk)
	    offset += len(chunk)
	cont = ''.join(content)
    finally:
        try:
            prev_file.close()
        except:
            pass

    # Create new version
    next_ver = max_ver + 1
    new_version_name = base + ".v" + str(next_ver)
    res = openfile(new_version_name, True)
    try:
        if not cont:
            wrt = ""
        else:
            wrt = cont
        res.writeat(wrt, 0)
    except Exception:
        try:
            res.close()
        except:
            pass
        raise

    lock_file.append(new_version_name + ".lock")
    return VMFile(new_version_name, True, res)

def LPremovefile(filename):
    raise RepyArgumentError("Remove File is not supported")

def LPlistfiles():
    files = listfiles()
    bases = []
    seen = set()
    for i in files:
        if sani_sep(i, 1):
            base = sani_sep(i, 2)
        else:
            base = i
        if base not in seen:
            seen.add(base)
            bases.append(base)
    return bases

# ---------------------------------------------------------------------
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)),
                "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str,
               "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)),
              "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code (security layer harness)
secure_dispatch_module()
