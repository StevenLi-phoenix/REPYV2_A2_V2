TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

class VMFile():
    def __init__(self, filename, create):
    # If a file with the same 'filename' already exists, this creates a new version 'filename.v1'.
    # (Incomplete: does not handle further versions like v2, v3, etc.)
    
        self.filename = filename
        self.writable = True
    
    #spec 4 file in use 
        try:
            testfile = openfile(filename, False)
            testfile.close()
        except FileNotFoundError:
            pass
        except FileInUseError:
            raise FileInUseError("File is already open")

     
    #spec5 case cannot create explicit version files 
        if '.v' in filename:
            parts = filename.rsplit('.v', 1)
            if len(parts) == 2 and parts[1].isdigit():
                if create:
                    raise RepyArgumentError("Cannot create explicit version files")
                self.writable = False
                 
        if create:
            files = listfiles()
            # spec 3 if file exisits make new version
            if filename in files:
                # find highest version number
                ver = 0
                for f in files:
                    if f.startswith(filename + '.v'):
                        try:
                            parts = f.split('.v')
                            num = int(parts[-1])
                            if num > ver:
                                ver = num
                        except:
                            pass

                if ver == 0:
                    latest = filename
                else:
                    latest = filename + '.v' + str(ver)

                try:
                    tmp = openfile(latest, False)
                    tmp.close()
                except FileInUseError:
                    raise FileInUseError("File is already open")
                
                ver = ver + 1
                newname = filename + '.v' + str(ver)
                
                # copy old content
                if ver == 1:
                    prev_file = openfile(filename, False)
                else:
                    prev_file = openfile(filename + '.v' + str(ver - 1), False)
                
                content = prev_file.readat(None, 0)
                prev_file.close()
                
                # make new version
                
                self.VMfile = openfile(newname, True)
                if content:
                    self.VMfile.writeat(content, 0)
                
                self.filename = newname
            else:
                # new file
                
                self.VMfile = openfile(filename, True)
        else:
            # spec 6 open file if version existis 
            
            files = listfiles()
            if filename not in files:
                raise FileNotFoundError("File not found")
            
            self.VMfile = openfile(filename, False)
            
            # if  file has versions make immutable 
            
            if '.v' not in filename:
                for f in files:
                    if f.startswith(filename + '.v'):
                        self.writable = False
                        break

            # make explicit version files immutable
            
            if '.v' in filename:
                parts = filename.rsplit('.v', 1)
                if len(parts) == 2 and parts[1].isdigit():
                    self.writable = False

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
    #spec 7 continued 
        if not self.writable:
            raise FileInUseError("Cannot write to an old version")
    
        if not isinstance(data, str):
            raise RepyArgumentError("Data must be a string")
        if not isinstance(offset, int) or offset < 0:
            raise RepyArgumentError("Offset must be a non-negative integer")

        return self.VMfile.writeat(data, offset)


    def close(self):
        return self.VMfile.close()


def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
   #spec 8 file deletion is not allowed
    raise RepyArgumentError("File deletion is not allowed")


def LPlistfiles():
#spec9 file listing 
    files = listfiles()
    result = []
    seen = set()
    for f in files:
        if '.v' in f:
            parts = f.rsplit('.v', 1)
            if len(parts) == 2 and parts[1].isdigit():
                base = parts[0]
                if base not in seen:
                    result.append(base)
                    seen.add(base)
                continue
        if f not in seen:
            result.append(f)
            seen.add(f)
    return result


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}
# Execute the user code
secure_dispatch_module()
