"""
This security layer handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

#tracking for any files that are open atm
class FileTracker:
    open_files = {}  #filename -> file obj
    open_for_write = {}  #base filename -> actual filename (writable files only!!)
    open_base_names = {}  #base filename -> set of all filenames using that base

class VMFile():
    def __init__(self, filename, create):
        
        #trying to make explicit version? not allowed
        #also, ensures that version files must end with .v followed by only digits
        if create and ".v" in filename:
            parts = filename.rsplit(".v", 1)
            if len(parts) == 2 and parts[1].isdigit():
                raise RepyArgumentError("Womp womp -- can't create explicit version files.")

        #determine base filename (wout version suffix... so like "testfile.v1" -> "testfile")
        #also, only treat as version file if it looks like this .v<digits>
        if ".v" in filename:
            parts = filename.rsplit(".v", 1)
            if len(parts) == 2 and parts[1].isdigit():
                #it's version, so like "testfile.v1" -> base is "testfile"
                base_name = parts[0]
            else:
                #has .v but not a version file, so like "test.v.data" -> base is "test.v.data"
                base_name = filename
        else:
            base_name = filename
        
        #check if opening a versioned file
        if ".v" in filename:
            parts = filename.rsplit(".v", 1)
            is_version_file = len(parts) == 2 and parts[1].isdigit()
        else:
            is_version_file = False

        if is_version_file:
            #opening an old version... read-only only
            #check if THIS SPECIFIC VERSION is alr open
            if filename in FileTracker.open_files:
                raise FileInUseError("File's already open.")
            
            #check if base is open for writing
            if base_name in FileTracker.open_for_write:
                raise FileInUseError("File's already open.")
            
            if filename not in listfiles():
                raise FileNotFoundError("File not found.")
            
            self.VMfile = openfile(filename, False)
            self.filename = filename
            self.base_name = base_name
            self.is_old_version = True  #read-only
            self.is_writable = False
            FileTracker.open_files[filename] = self.VMfile
            
            #track by base name
            if base_name not in FileTracker.open_base_names:
                FileTracker.open_base_names[base_name] = set()
            FileTracker.open_base_names[base_name].add(filename)

        elif create:
            #creating or versioning a file (aka writable)
            #check if base's alr open for writing
            if base_name in FileTracker.open_for_write:
                raise FileInUseError("File's already open.")
            
            #check if ANY file w this base name is alr open (read or write)
            if base_name in FileTracker.open_base_names and len(FileTracker.open_base_names[base_name]) > 0:
                raise FileInUseError("File's already open.")
            
            all_files = listfiles()
            
            if filename in all_files:
                #file exists, create new version
                #scan files to find highest version
                highest_version = 0
                for f in all_files:
                    if f.startswith(filename + ".v"):
                        try:
                            #get version number, so like testfile.v2 -> 2
                            version_str = f[len(filename) + 2:]
                            version_num = int(version_str)
                            if version_num > highest_version:
                                highest_version = version_num
                        except ValueError:
                            #version num not valid
                            pass
                
                #determine which file to read from
                if highest_version == 0:
                    #no versions yet, read from base
                    source_file = filename
                else:
                    #read latest version
                    source_file = filename + ".v" + str(highest_version)
                
                #read content from source
                prev_file = openfile(source_file, False)
                content = prev_file.readat(None, 0)
                prev_file.close()
                
                #make new version
                new_version = highest_version + 1
                new_name = filename + ".v" + str(new_version)
                self.VMfile = openfile(new_name, True)
                self.VMfile.writeat(content, 0)
                self.filename = new_name
                self.base_name = base_name
                self.is_old_version = False
                self.is_writable = True
                
                #track this file as open for writing
                FileTracker.open_files[new_name] = self.VMfile
                FileTracker.open_for_write[base_name] = new_name
                
                #track by base name
                if base_name not in FileTracker.open_base_names:
                    FileTracker.open_base_names[base_name] = set()
                FileTracker.open_base_names[base_name].add(new_name)
            else:
                #file doesn't exist, so make new base
                self.VMfile = openfile(filename, True)
                self.filename = filename
                self.base_name = base_name
                self.is_old_version = False
                self.is_writable = True
                FileTracker.open_files[filename] = self.VMfile
                FileTracker.open_for_write[base_name] = filename
                
                if base_name not in FileTracker.open_base_names:
                    FileTracker.open_base_names[base_name] = set()
                FileTracker.open_base_names[base_name].add(filename)
        else:
            #opening existing file wout create (aka read-only)
            if filename not in listfiles():
                raise FileNotFoundError("File not found.")
            
            #check if THIS SPECIFIC file is alr open
            if filename in FileTracker.open_files:
                raise FileInUseError("File's already open.")
            
            #check if base's open for writing
            if base_name in FileTracker.open_for_write:
                raise FileInUseError("File's already open.")
            
            self.VMfile = openfile(filename, False)
            self.filename = filename
            self.base_name = base_name

            #base file = read-only once versions exist
            self.is_old_version = self._check_if_old_version(filename)
            self.is_writable = False
            FileTracker.open_files[filename] = self.VMfile
            
            if base_name not in FileTracker.open_base_names:
                FileTracker.open_base_names[base_name] = set()
            FileTracker.open_base_names[base_name].add(filename)

    #checks if file should be treated as read only or not
    #my logic is that there are two ways that a file is read-only:
    #1. it's explicitly a version (so like testfile.v1, testfile.v2, testfile.vX, etc)
    #2. it's a base file that has versions (because the base becomes immutable once versioning begins... new writes go to new versions)
    #TLDR: reading from older versions is always allowed, butttt writing to them is permanently disallowed
    def _check_if_old_version(self, filename):
        #if versioned file (so like .v1, .v2, .vX, etc.), then always read-only
        if ".v" in filename:
            parts = filename.rsplit(".v", 1)
            if len(parts) == 2 and parts[1].isdigit():
                return True  #it's a version file, otherwise it just has .v in the name but isn't a version file
        
        #if base file, check if versions exist
        all_files = listfiles()
        for f in all_files:
            if f.startswith(filename + ".v"):
                #versions exist, so base is read-only
                return True
        return False

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self.is_old_version:
            raise FileInUseError("Oh naurrr -- can't write to a read-only file.")
        return self.VMfile.writeat(data, offset)

    def close(self):
        #remove from open files tracking
        if self.filename in FileTracker.open_files:
            del FileTracker.open_files[self.filename]
        if self.is_writable and self.base_name in FileTracker.open_for_write:
            del FileTracker.open_for_write[self.base_name]
        
        #remove from base name tracking
        if self.base_name in FileTracker.open_base_names:
            FileTracker.open_base_names[self.base_name].discard(self.filename)
            #clean up empty sets
            if len(FileTracker.open_base_names[self.base_name]) == 0:
                del FileTracker.open_base_names[self.base_name]
        
        return self.VMfile.close()


def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    raise RepyArgumentError("File deletion is not allowed.")

def LPlistfiles():
    all_files = listfiles()
    #filter out version files
    base_files = []
    for f in all_files:
        if ".v" not in f:
            base_files.append(f)
        else:
            #check if it's a version file
            parts = f.rsplit(".v", 1)
            if len(parts) == 2:
                try:
                    int(parts[1])  #try to parse as version number
                    #it's a version file, so don't include it
                    continue
                except ValueError:
                    #not a version number, include it
                    base_files.append(f)
            else:
                base_files.append(f)
    return base_files


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()