"""
name: reference_monitor_nm4358.r2py
This security layer should adequately handle the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python2 repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""

# python2 repy.py restrictions.default encasementlib.r2py reference_monitor_nm4358.r2py nm4358_attackcase.r2py
# dummy run
# python2 repy.py restrictions.default encasementlib.r2py reference_monitor_nm4358.r2py test_defense.r2py

# Import Repy encasement layer
# include encasementlib.r2py

"""
Notes:
print is unsafe, use log. import is unsafe. global is unsafe. 
- Keeps track of open handles we created through VMFile instances:
- maps actual filename -> open count (for write/read as needed). Use for concurrency checks
- Complies with RepyV2 sandbox: no imports, no print, no global.
"""

# Import Repy encasement layer
# include encasementlib.r2py


TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"


_INTERNAL_TRACKER = {'files': []}

def _remember(fname):
    if fname not in _INTERNAL_TRACKER['files']:
        _INTERNAL_TRACKER['files'].append(fname)
    if fname not in internal_files:
        internal_files.add(fname)

"""
Returns a secure dispatch dictionary implementing versioned, immutable file semantics.
Uses only closure variables for internal state (no globals/imports/print).
"""

internal_files = set()
open_counts = {}

# --- helpers ---
def is_digits(s):
    if s == None or s == "":
      return False
    for ch in s:
      if ch < "0" or ch > "9":
        return False
    return True

def extract_version_number(filename):
    idx = filename.rfind(".v")
    if idx == -1:
      return 0
    suffix = filename[idx+2:]
    if suffix == "" or not is_digits(suffix):
      return 0
    try:
      return int(suffix)
    except:
      return 0

def is_versioned_name(filename):
    return extract_version_number(filename) != 0

def get_all_versions(filename):
    vers = []
    for f in internal_files:
      if f == filename or (f.startswith(filename + ".v") and is_versioned_name(f)):
        vers.append(f)
    return vers

def get_all_versions_including_hidden(base):
    # Filter by prefix
    result = []
    for f in _INTERNAL_TRACKER['files']:
        if f == base or f.startswith(base + ".v"):
            result.append(f)
    return result

def get_latest_version_real(filename):
    versions = get_all_versions_including_hidden(filename)
    if not versions:
      return None
    maxn = -1
    latest = None
    for f in versions:
      num = extract_version_number(f)
      if num > maxn:
        maxn = num
        latest = f
    return latest

def get_latest_version(filename):
    versions = get_all_versions(filename)
    if not versions:
      return None
    maxn = -1
    latest = None
    for f in versions:
      num = extract_version_number(f)
      if num > maxn:
        maxn = num
        latest = f
    return latest

def get_next_version_name(filename):
    latest = get_latest_version(filename)
    if latest is None:
      return filename
    latest_num = extract_version_number(latest)
    if latest_num == 0:
      return filename + ".v1"
    else:
      return filename + ".v" + str(latest_num + 1)

def increment_count(name):
    if not name in open_counts:
      open_counts[name] = 1
    else:
      open_counts[name] = open_counts[name] + 1

def decrement_count(name):
    if name in open_counts:
      open_counts[name] = open_counts[name] - 1
      if open_counts[name] <= 0:
        del open_counts[name]

# --- class ---
class VMFile:
    def __init__(self, filename, create):
      # Disallow explicit version creation
      if is_versioned_name(filename) and create:
        raise RepyArgumentError("Cannot create explicit version files")

      # Determine if creating new or opening existing
      latest = get_latest_version(filename)
      if create:
        # If the latest version is open, disallow
        if latest != None and open_counts.get(latest, 0) > 0:
          raise FileInUseError("Latest version open; cannot create new")

        newname = get_next_version_name(filename)

        # Copy data from previous version
        data = None
        if latest != None:
          rf = openfile(latest, False)
          _remember(latest)
          try:
            data = rf.readat(None, 0)
          finally:
            rf.close()

        self.filename = newname
        self.latest = True
        self.VMfile = openfile(newname, True)
        _remember(newname)
        internal_files.add(newname)
        if data != None:
          self.VMfile.writeat(data, 0)
        increment_count(self.filename)

      else:
        # Must exist
        allv = get_all_versions_including_hidden(filename)
        if filename not in allv:
          raise FileNotFoundError(filename + " not found")
        base = filename.split(".v")[0]
        latest_real = get_latest_version_real(base)
        self.filename = filename
        self.latest = (filename == latest_real)
        self.VMfile = openfile(filename, False)
        _remember(filename)
        increment_count(self.filename)

    def readat(self, nbytes, offset):
      return self.VMfile.readat(nbytes, offset)

    def writeat(self, data, offset):
        # Immutable older versions are never writable
        if not self.latest:
            raise FileInUseError("Cannot write to old version")
        # Defensive check: disallow writing to files opened read-only
        try:
            return self.VMfile.writeat(data, offset)
        except Exception:
            raise FileInUseError("Cannot modify older file versions")

    def close(self):
      try:
        return self.VMfile.close()
      finally:
        decrement_count(self.filename)

# --- file API wrappers ---
def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    raise RepyArgumentError("removefile forbidden")

def LPlistfiles():
    raw = listfiles()
    base = set()
    for f in raw:
      idx = f.rfind(".v")
      if idx != -1:
        suffix = f[idx+2:]
        if is_digits(suffix) and suffix != "":
          base.add(f[:idx])
        else:
          base.add(f)
      else:
        base.add(f)
    return list(base)



# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()