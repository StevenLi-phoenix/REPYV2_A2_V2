"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

allFiles = []

class VMFile():

    def __init__(self, filename, create):
        # If a file with the same 'filename' already exists, this creates a new version 'filename.v1'.
        
        self.filename = filename
        if create:

            # should not create explicit Versioned files
            if is_explicit_version(filename):
                raise RepyArgumentError("Cannot create explicit version files")
            
            # File exists → create new version
            if filename in listfiles():
                latest_version = get_latest_version(filename)

                # Should not create new version if latest version of the file is open
                try:
                    prev_file = openfile(create_versioned_filename(filename, latest_version),False)
                except:
                    raise FileInUseError("Cannot create new version since latest version is open")
                
                content = prev_file.readat(None, 0)

                new_name = create_versioned_filename(filename, latest_version + 1)
                self.VMfile = openfile(new_name, True)
                self.filename = new_name
                self.VMfile.writeat(content, 0)
            else:
                # File doesn't exist → create filename
                self.VMfile = openfile(filename, True)
                allFiles.append(filename)
        else:
            # Open existing file 
            if filename in listfiles():
                try:
                    self.VMfile = openfile(filename, False)
                except:
                    raise FileInUseError("File already open")
            else:
                raise FileNotFoundError("File does not exist")

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        filename = self.filename
        latest_version = get_latest_version(filename)

        # writing allowed only in latest version files
        if is_explicit_version(filename) and (int(filename.split('.v')[1]) == latest_version):
            return self.VMfile.writeat(data, offset)
        elif not is_explicit_version(filename) and latest_version == 0:
            return self.VMfile.writeat(data, offset)
        else:
            raise FileInUseError("Cannot write to older version files")

    def close(self):
        return self.VMfile.close()

# helper method to check if the given file is a versioned file
def is_explicit_version(filename):
    if '.v' in filename:
        if len(filename.split('.v')) > 1 and filename.split('.v')[1].isdigit():
            return True
    return False

# helper method to get latest version of the file
def get_latest_version(filename):
    res = 0
    version = 0
    filename_base = filename.split('.v')[0]

    for file in listfiles():
        temp = file.split('.v')
        if len(temp) > 1 and temp[1].isdigit():
            version = int(temp[1])
        base = temp[0]
        if base == filename_base:
            res = max(res, version)
    return int(res)

# helper method to create filename with version
def create_versioned_filename(base, version):
    if version == 0:
        return base
    return base + '.v' + str(version)

def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    raise RepyArgumentError("File Deletion not allowed")

# should just list the files regardless of versions
def LPlistfiles():
    return allFiles

# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()