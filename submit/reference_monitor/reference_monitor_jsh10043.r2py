"""
CSGY-6813 Assignment 2.1
Josh Hoge
jsh10043@nyu.edu

This security layer implements versioned and immutable file functionality,
using Python 2.7, repy.py, restrictions.default, and encasementlib.r2py.

Specifications:
1. The reference monitor should incorporate all the standard file operation
methods supported in RepyV2, from opening a file, reading and writing to it,
listing files, deleting files, and to closing them. All operations must behave
identically to RepyV2 (without the security layer) except as mentioned below.

2. Assume that no files exist when the security layer begins running the
application.

3. When a user calls openfile(filename, True), if filename already exists, the
security layer must create a new “version”, which is a new file initialized
with the contents of the latest version and given a new version number.

4. Note that a new version cannot be created while the latest version is open.
If openfile() is called on an already open file, it shall throw the relevant
error that it would have done in RepyV2 (FileInUseError).

5. Versioned files can be accessed using:
openfile(originalfilename + '.v' + str(num), create)
where num starts from 1. If create=True is used on a versioned file, raise:
RepyArgumentError("Cannot create explicit version files"), as manual version
creation is not allowed.

6. As is the case in normal RepyV2, if an openfile call with create=False, open
the file only if that version exists; otherwise, raise FileNotFoundError.

7. Reading from older versions is always allowed, but writing to them is
permanently disallowed. Any attempt to write to an older version should
raise a FileInUseError.

8. File deletion (removefile) is not allowed for any file. Any attempt must
raise a RepyArgumentError.

9. The listfiles() call in RepyV2 should not show that versions of files exist.
It should just show the listing of all files that were created, regardless of
how many versions of those file exist.

10. RepyV2 filenames must only contain lowercase letters, numbers, hyphens,
underscores, and periods (a-z0-9._-), cannot start with a period or be empty,
and are limited to 120 characters maximum. There is no concept of directories
or folders in RepyV2, so all files exist in a single flat namespace.

11. Do not make any changes to the code that sets up type checking and
variable hiding, located in the coda at the bottom of this file.

12. Never raise unexpected errors or produce any output. The reference monitor
must produce no output when run normally, with a valid attack case. Make sure
that any log() statements used for debugging are removed.

"""

# constant definitions
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

# initialize mycontext for state tracking
if "open_files" not in mycontext:
    mycontext["open_files"] = {}  # track currently open files
    mycontext["version_lock"] = createlock()  # lock for thread safety


# extract base name and version number from a filename
def parse_version(filename):
    # check if filename ends with .v[digits]
    if ".v" not in filename:
        return (filename, None)

    # find the last occurrence of .v (possibly more than one in a filename)
    parts = filename.split(".v")
    if len(parts) < 2:
        return (filename, None)

    # check if the last part is all digits and only digits, nothing else
    last_part = parts[-1]
    if last_part.isdigit() and len(last_part) > 0:
        version_number = int(last_part)
        basename = ".v".join(parts[:-1])
        return (basename, version_number)

    # return the tuple
    return (filename, None)


# check if filename is an old version
def is_old_version(filename):
    basename, version = parse_version(filename)
    return version is not None


# find the highest version number of a filename
def conflicts_with_version_namespace(filename):
    if ".v" not in filename:
        return False

    # split on .v and check what comes after the last .v
    parts = filename.split(".v")
    if len(parts) < 2:
        return False

    last_part = parts[-1]

    # case 1: nothing after .v (e.g., "data.v")
    if len(last_part) == 0:
        return True

    first_char = last_part[0]

    # case 2: first char is digit (e.g., "data.v1", "data.v123")
    if first_char.isdigit():
        return True

    # case 3: first char is hyphen (e.g., "data.v-1")
    if first_char == "-":
        return True

    # case 4: starts with letter (e.g., "data.vault", "archive.version")
    return False


# find the highest version number of a filename
def get_latest_version_number(basename):
    all_files = listfiles()
    max_version = 0

    # loop through the files
    for f in all_files:
        base, ver = parse_version(f)
        if base == basename and ver is not None and ver > max_version:
            max_version = ver

    # return the highest version
    return max_version


# get the filename of the latest version
def get_latest_version_filename(basename):
    max_version = get_latest_version_number(basename)

    if max_version == 0:
        # no filename versions exist
        return basename
    else:
        return basename + ".v" + str(max_version)


# reqiured wrapper for RepyV2 file operations
class VMFile:
    # initialize the VMFile object
    def __init__(self, filename, create, fileobj=None, initial_content=None):
        self.filename = filename
        self.writable = create  # track if file is opened for writing

        # if fileobj was provided, use it; otherwise open the file
        if fileobj is not None:
            self.VMfile = fileobj
        else:
            self.VMfile = openfile(filename, create)

        # if initial_content provided, write it to the file
        if initial_content is not None and len(initial_content) > 0:
            self.VMfile.writeat(initial_content, 0)

    # readat method
    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    # writeat method
    def writeat(self, data, offset):
        # files opened with create=False are read-only; base and versioned files
        if not self.writable:
            raise FileInUseError("Cannot write to read-only file")

        return self.VMfile.writeat(data, offset)

    # close method
    def close(self):
        # remove from open files tracking
        if self.filename in mycontext["open_files"]:
            del mycontext["open_files"][self.filename]
        return self.VMfile.close()


# reference monitor wrapper for openfile; the main brain
def LPopenfile(filename, create):
    # validate that filename doesn't conflict with versioning namespace
    if create and conflicts_with_version_namespace(filename):
        raise RepyArgumentError("Filename conflicts with version naming scheme")

    # prevent manual creation of explicit version files
    if create and is_old_version(filename):
        raise RepyArgumentError("Cannot create explicit version files")

    # ensure lock exists to protect against deletion by malicious code
    if "version_lock" not in mycontext or mycontext["version_lock"] is None:
        mycontext["version_lock"] = createlock()

    # ensure open_files dict exists to protect against deletion
    if "open_files" not in mycontext or not isinstance(mycontext["open_files"], dict):
        mycontext["open_files"] = {}

    # acquire lock... because we need thread safety
    mycontext["version_lock"].acquire(True)
    try:
        if create:
            # parse the filename to get basename
            basename, _ = parse_version(filename)

            # check if base file exists
            all_files = listfiles()
            if basename in all_files:
                # file exists, so create a new version; find the highest version number
                latest_version_num = get_latest_version_number(basename)

                # determine the latest version filename
                if latest_version_num == 0:
                    latest_filename = basename
                else:
                    latest_filename = basename + ".v" + str(latest_version_num)

                # check if the latest version is already open
                if latest_filename in mycontext["open_files"]:
                    raise FileInUseError("File is already open")

                # create new version
                next_version = latest_version_num + 1
                new_version_filename = basename + ".v" + str(next_version)

                # copy content from the latest version
                source = openfile(latest_filename, False)
                try:
                    content = source.readat(None, 0)
                finally:
                    source.close()

                # create the new version file with copied content
                new_file = openfile(new_version_filename, True)

                # track the file as open
                mycontext["open_files"][new_version_filename] = True

                # return VMFile for the NEW version with initial content
                return VMFile(new_version_filename, True, new_file, content)
            else:
                # file doesn't exist, so create base file
                mycontext["open_files"][basename] = True
                return VMFile(basename, True)
        else:
            # opening existing file for reading, so check if file actually exists
            if filename not in listfiles():
                raise FileNotFoundError("File not found")

            # check if file is already open
            if filename in mycontext["open_files"]:
                raise FileInUseError("File is already open")

            # track the file as open
            mycontext["open_files"][filename] = True
            return VMFile(filename, False)
    finally:
        # release lock
        mycontext["version_lock"].release()


# reference monitor wrapper for closefile; completely disabled per spec
def LPremovefile(filename):
    # always return an error
    raise RepyArgumentError("File deletion is not allowed")


# reference monitor wrapper for listfiles; total time vampire
def LPlistfiles():
    # get all files
    all_files = listfiles()

    # build list of indices to remove so versioned files aren't revealed
    indices_to_remove = []

    # loop through the files
    for i in range(len(all_files)):
        if is_old_version(all_files[i]):
            indices_to_remove.append(i)

    # remove indices in reverse order to maintain correct positions
    for i in range(len(indices_to_remove) - 1, -1, -1):
        all_files.pop(indices_to_remove[i])

    # return the list
    return all_files


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {
        "type": "func",
        "args": (str, (int, long)),
        "exceptions": Exception,
        "return": (int, type(None)),
        "target": VMFile.writeat,
    },
    "readat": {
        "type": "func",
        "args": ((int, long, type(None)), (int, long)),
        "exceptions": Exception,
        "return": str,
        "target": VMFile.readat,
    },
    "close": {
        "type": "func",
        "args": None,
        "exceptions": Exception,
        "return": (bool, type(None)),
        "target": VMFile.close,
    },
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile,
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile,
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles,
}

# Execute the user code
secure_dispatch_module()
