TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

_base_versions = {} # track versions
_version_in_use = {} # track if a version for a file is in use

def _get_version(name):
    parts = name.rsplit(".v", 1)
    if len(parts) != 2:
        return None
    base, numpart = parts
    if not numpart.isdigit():
        return None
    return (base, int(numpart))

def _create_next_version(base):
    v = _base_versions.get(base, 0) + 1
    _base_versions[base] = v
    return base + ".v" + str(v), v

class VMFile():
    def __init__(self, filename, create):
        self._writable = False
        self._closed = False
        self._name = filename

        verinfo = _get_version(filename)
        if verinfo:
            base = verinfo[0]
        else:
            base = filename

        if create:
            if verinfo:
                raise RepyArgumentError("Cannot create explicit version files")

            if _version_in_use.get(base, False):
                raise FileInUseError("Cannot create a new version while previous version is open")

            existing_files = listfiles()
            found_existing = False
            for fn in existing_files:
                if fn == base or fn.startswith(base + ".v"):
                    found_existing = True
                    break

            if found_existing:
                old_ver = _base_versions.get(base, 0)
                new_name, new_ver = _create_next_version(base)
                newf = openfile(new_name, True)

                _version_in_use[base] = True
                try:
                    if old_ver == 0:
                        src_name = base
                    else:
                        src_name = base + ".v" + str(old_ver)

                    # load file in 32Kib chunks to avoid loading full file into memory 
                    src = openfile(src_name, False)
                    offset = 0
                    chunk = 32768
                    while True:
                        data = src.readat(chunk, offset)
                        if not data:
                            break
                        newf.writeat(data, offset)
                        offset += len(data)
                    src.close()

                    self.VMfile = newf
                    self._name = new_name
                    self._writable = True
                except:
                    _version_in_use[base] = False
                    raise
            else:
                _base_versions[base] = 0
                self.VMfile = openfile(base, True)
                self._name = base
                self._writable = True
                _version_in_use[base] = True

        else:
            # Read-only opens
            self.VMfile = openfile(filename, False)
            self._writable = False

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self._closed or not self._writable:
            raise FileInUseError("Writes not allowed on this version")
        return self.VMfile.writeat(data, offset)

    def close(self):
        res = self.VMfile.close()
        self._closed = True
        if self._writable:
            verinfo = _get_version(self._name)
            if verinfo is not None:
                base = verinfo[0]
            else:
                base = self._name
            _version_in_use[base] = False
            self._writable = False
        return res


def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    raise RepyArgumentError("File deletion not allowed")

def LPlistfiles():
    seen = set()
    result = []
    for f in listfiles():
        verinfo = _get_version(f)
        if verinfo:
            base = verinfo[0]
        else: 
            base = f
        if base not in seen:
            seen.add(base)
            result.append(base)

    return result

# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()