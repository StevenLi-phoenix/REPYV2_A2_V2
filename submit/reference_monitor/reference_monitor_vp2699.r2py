"""
refrence_monitor_vp2699.r2py

"""

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

#For tracking currently openend files
open_files = {}

class VMFile():
    
    def __init__(self, filename, create):
        self.filename = filename

        self.is_version_file = False   #True if the name looks like "name.vN"
        self.version_number = None     #If versioned, the integer N
        self.is_old_version = False    #True if this wrapper is for a read-only older version

        if ".v" in filename:
            #splits only on the last ".v" so names like "p.vb.v2" still work
            parts = filename.rsplit(".v", 1)
            if len(parts) == 2:
                try:
                    self.version_number = int(parts[1])
                    self.is_version_file = True
                    self.base_filename = parts[0]
                except ValueError:
                    pass

        #If its a version file like "abc.v1", open it in read-only mode
        if self.is_version_file:
            if filename not in listfiles():
                raise FileNotFoundError("Version file does not exist")

            self.VMfile = openfile(filename, False)
            self.is_old_version = True

        else:
            if create:
                #When create=True we must either create the base file (if it doesn't exist)
                #or create a new version if the base already exists
                #and if someone already has this base open, we must not proceed
                if filename in open_files:
                    raise FileInUseError("File is already open")

                if filename in listfiles():
                    #Scan existing filenames to find the highest version number
                    highest_version = 0
                    all_files = listfiles()

                    for f in all_files:
                        if f.startswith(filename + ".v"):
                            version_part = f[len(filename + ".v"):]
                            try:
                                ver_num = int(version_part)
                                if ver_num > highest_version:
                                    highest_version = ver_num
                            except ValueError:
                                pass

                    #Make sure to ensure the latest version file is not open, before creating a new version file
                    if highest_version > 0:
                        latest_version_name = filename + ".v" + str(highest_version)
                        if latest_version_name in open_files:
                            raise FileInUseError("Latest version is already open")

                    elif filename in open_files:
                        raise FileInUseError("File is already open")

                    #preparing to make new version
                    new_version = highest_version + 1
                    new_version_name = filename + ".v" + str(new_version)

                    #copying the content from the most recent file
                    if highest_version > 0:
                        prev_version_name = filename + ".v" + str(highest_version)
                        prev_file = openfile(prev_version_name, False)
                    else:
                        prev_file = openfile(filename, False)

                    content = prev_file.readat(None, 0)
                    prev_file.close()

                    self.VMfile = openfile(new_version_name, True)
                    self.VMfile.writeat(content, 0)

                    self.actual_filename = new_version_name
                    self.is_old_version = False

                else:
                    self.VMfile = openfile(filename, True)
                    self.actual_filename = filename
                    self.is_old_version = False

                open_files[filename] = self

            else:
                #if caller wants to open an existing file
                if filename not in listfiles():
                    raise FileNotFoundError("File does not exist")

                #open the file and remember its name
                self.VMfile = openfile(filename, False)
                self.actual_filename = filename
                self.is_old_version = False

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    #monitor blocks writes to older version files.
    def writeat(self, data, offset):
        if self.is_version_file or self.is_old_version:
            raise FileInUseError("Cannot write to old versions")
        return self.VMfile.writeat(data, offset)

    #removing the base from our open file tracker so new versions can be opened/created
    def close(self):
        if self.filename in open_files:
            del open_files[self.filename]
        return self.VMfile.close()

#to prevent manual creation of explicit .vN files.
def LPopenfile(filename, create):

    if create and ".v" in filename:
        parts = filename.rsplit(".v", 1)
        if len(parts) == 2:
            try:
                int(parts[1])
                raise RepyArgumentError("Cannot create explicit version files")
            except ValueError:
                pass

    return VMFile(filename, create)

#removefile is not allowed
def LPremovefile(filename):
    raise RepyArgumentError("File deletion is not allowed")

#listfiles should hide versioned names
def LPlistfiles():
    all_files = listfiles()
    result = []

    for f in all_files:
        if ".v" in f:
            parts = f.rsplit(".v", 1)
            if len(parts) == 2:
                try:
                    int(parts[1])
                    base_name = parts[0]
                    #adding the base only once
                    if base_name not in result:
                        result.append(base_name)
                    continue
                except ValueError:
                    pass
        #normal file or not-a-version then add if not already in result
        if f not in result:
            result.append(f)

    return result


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()