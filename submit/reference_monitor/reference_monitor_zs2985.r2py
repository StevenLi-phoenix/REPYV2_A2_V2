"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

# Global variable to track open files
open_files = set()


class VMFile():
    def __init__(self, filename, create):
        self.filename = filename
        self.is_version_file = False
        self.new_name = None
        self.create = create
        
        # Validate filename according to RepyV2 rules
        self._validate_filename(filename)
        
        if create:
            # Check if this is an explicit version file creation attempt
            if self._is_version_filename(filename):
                raise RepyArgumentError("Cannot create explicit version files")
            
            # Check if file already exists
            if filename in listfiles():
                # File exists → create new version
                # Find the latest version file to copy content from
                latest_file = self._get_latest_version_file(filename)
                
                # Check if the latest file is currently open
                if latest_file in open_files:
                    raise FileInUseError("Cannot create new version while file is open")

                prev_file = openfile(latest_file, False)
                content = prev_file.readat(None, 0)
                prev_file.close()
                
                # Find the next version number
                version_num = self._get_next_version_number(filename)
                new_name = filename + ".v" + str(version_num)
                self.VMfile = openfile(new_name, True)
                self.VMfile.writeat(content, 0)

                # Add to open files set
                open_files.add(new_name)
                self.new_name = new_name
            else:
                # File doesn't exist → create filename
                self.VMfile = openfile(filename, True)
                
                # Add to open files set
                open_files.add(filename)
        else:
            # Open existing file normally
            # Check if the file is currently open
            if filename in open_files:
                raise FileInUseError("Cannot open file that is already open")
            
            self.VMfile = openfile(filename, False)
            # Check if this is a version file
            if self._is_version_filename(filename):
                self.is_version_file = True

            # Add to open files set
            open_files.add(filename)
    
    def _is_version_filename(self, filename):
        """Check if filename is a version file like 'file.v2'"""
        # Check if filename contains '.v' followed by digits at the end
        if '.v' not in filename:
            return False
        
        # Find the position of '.v'
        v_pos = filename.rfind('.v')
        if v_pos == -1:
            return False
        
        # Check if everything after '.v' is digits
        version_part = filename[v_pos + 2:]  # Skip '.v'
        if not version_part:
            return False
        
        # Check if all characters after '.v' are digits
        for char in version_part:
            if not char.isdigit():
                return False
        
        return True
    
    def _get_next_version_number(self, filename):
        """Get the next version number for a file"""
        all_files = listfiles()
        max_version = 0
        
        for file in all_files:
            if file.startswith(filename + ".v"):
                # Extract version number
                version_part = file[len(filename) + 2:]  # Remove "filename.v"
                if version_part.isdigit():
                    version_num = int(version_part)
                    if version_num > max_version:
                        max_version = version_num
        
        return max_version + 1
    
    def _get_latest_version_file(self, filename):
        """Get the filename of the latest version of a file"""
        all_files = listfiles()
        max_version = 0
        latest_file = filename  # Default to original filename
        
        for file in all_files:
            if file.startswith(filename + ".v"):
                # Extract version number
                version_part = file[len(filename) + 2:]  # Remove "filename.v"
                if version_part.isdigit():
                    version_num = int(version_part)
                    if version_num > max_version:
                        max_version = version_num
                        latest_file = file
        
        return latest_file
    
    def _validate_filename(self, filename):
        """Validate filename according to RepyV2 rules"""
        # Check if filename is empty
        if not filename:
            raise RepyArgumentError("Filename cannot be empty")
        
        # Check if filename is too long (max 120 characters)
        if len(filename) > 120:
            raise RepyArgumentError("Filename cannot be longer than 120 characters")
        
        # Check if filename starts with a period
        if filename.startswith('.'):
            raise RepyArgumentError("Filename cannot start with a period")
        
        # Check for forbidden names
        if filename in ['.', '..']:
            raise RepyArgumentError("Filename cannot be '.' or '..'")
        
        # Check if filename contains only allowed characters
        # Allowed: lowercase letters, numbers, hyphen, underscore, period
        allowed_chars = set('abcdefghijklmnopqrstuvwxyz0123456789-_.')
        for char in filename:
            if char not in allowed_chars:
                raise RepyArgumentError("Filename contains invalid character: '{}'. Only lowercase letters, numbers, hyphen, underscore, and period are allowed".format(char))

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        # Check if this is a version file (immutable)
        if self.is_version_file:
            raise FileInUseError("Cannot write to version file")
        if self.create != True:
            raise FileInUseError("Cannot write under read mode")
        return self.VMfile.writeat(data, offset)

    def close(self):
        # Remove from open files set
        if self.new_name == None:
            open_files.discard(self.filename)
        else:
            open_files.discard(self.new_name)
        return self.VMfile.close()


def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    # File deletion is not allowed
    raise RepyArgumentError("File deletion is not allowed")

def LPlistfiles():
    # Get all files from the underlying system
    all_files = listfiles()
    # Filter out version files (files ending with .v followed by digits)
    # Create a new list to avoid modifying the original
    result = []
    for file in all_files:
        if not _is_version_filename_static(file):
            result.append(file)
    # Convert list to string representation
    return str(result)

def _is_version_filename_static(filename):
    """Check if filename is a version file like 'file.v2'"""
    # Check if filename contains '.v' followed by digits at the end
    if '.v' not in filename:
        return False
    
    # Find the position of '.v'
    v_pos = filename.rfind('.v')
    if v_pos == -1:
        return False
    
    # Check if everything after '.v' is digits
    version_part = filename[v_pos + 2:]  # Skip '.v'
    if not version_part:
        return False
    
    # Check if all characters after '.v' are digits
    for char in version_part:
        if not char.isdigit():
            return False
    
    return True

# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: [str],
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()