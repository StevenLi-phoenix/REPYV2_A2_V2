#pragma repy
"""
This security layer inadequately handles the Versioned and Immutable functionality

Notes:
    Used ChatGPT for help

    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py


"""
# Import threading globally is disallowed, use createlock() below
# import threading - REMOVED

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

# --- Globals for State Management ---
file_versions = {}
# Use Repy's safe lock creation function instead of importing threading
file_versions_lock = createlock()
# version_pattern using 're' is removed, logic replaced with string methods

# --- Helper Functions ---

def _is_version_file(filename):
  """Checks if a filename matches the 'basename.vNUMBER' pattern using string methods."""
  # Check if '.v' exists and is not the entire filename or just '.'
  if '.v' not in filename or filename == '.v' or filename == '.':
      return False
  try:
      # Find the index of the last '.v'
      last_v_index = -1
      current_index = 0
      while True:
          found_index = filename.find('.v', current_index)
          if found_index == -1:
              break
          last_v_index = found_index
          current_index = found_index + 1 # Continue search after the found '.v'

      # If no '.v' found, or if it's at the beginning (invalid), return False
      if last_v_index <= 0:
          return False

      # Check if the part after '.v' consists only of digits
      version_part = filename[last_v_index + 2:] # Get the string after '.v'
      if not version_part: # Must have digits after '.v'
          return False
      for char_code in version_part:
          if not ('0' <= char_code <= '9'): # Check if each character is a digit
              return False
      # If all checks pass, it's likely a version file
      return True
  except: # Handle potential errors during string manipulation
      pass
  return False

def _parse_version_filename(filename):
    """
    Parses 'basename.vNUMBER' into (basename, number) using string methods.
    Returns (None, None) if the format is incorrect.
    """
    try:
        # Find the index of the last '.v'
        last_v_index = -1
        current_index = 0
        while True:
            found_index = filename.find('.v', current_index)
            if found_index == -1:
                break
            last_v_index = found_index
            current_index = found_index + 1

        if last_v_index <= 0: # Ensure '.v' is present and not at the start
            return None, None

        basename = filename[:last_v_index]
        num_str = filename[last_v_index + 2:]

        # Check if num_str contains only digits and is not empty
        if not num_str:
            return None, None
        is_digit = True
        for char_code in num_str:
            if not ('0' <= char_code <= '9'):
                is_digit = False
                break
        if is_digit:
            return basename, int(num_str)
    except: # Catch potential errors like int() conversion failure
        pass
    return None, None


def _get_latest_version_info(basename):
  # Assumes lock is held
  # No 're' import needed here

  if basename in file_versions:
    return file_versions[basename]['latest'], file_versions[basename]['open_handle']

  latest_num = 0
  all_files = listfiles() # Use underlying listfiles
  base_plus_dot = basename + "."
  base_exists = basename in all_files

  for f in all_files:
    # Check if it starts like a version file AND parse it
    if f.startswith(base_plus_dot):
      # Use string parsing helper instead of regex
      matched_base, num = _parse_version_filename(f)
      if matched_base == basename and num is not None:
          if num > latest_num:
            latest_num = num

  if base_exists or latest_num > 0:
      file_versions[basename] = {'latest': latest_num, 'open_handle': None}
      return latest_num, None
  else:
      return 0, None

def _get_versioned_filename(basename, version_num):
  if version_num == 0:
    return basename
  else:
    # Use simple string concatenation which is safe
    return basename + ".v" + str(version_num)

# --- Wrapped File Object ---
# <<< इंश्योर ओनली थिस क्लास डेफिनेशन इज़ प्रेजेंट >>>
class VMFile():
    def __init__(self, underlying_file_obj, basename, version_num, is_immutable):
        self.VMfile = underlying_file_obj
        self._basename = basename
        self._version_num = version_num
        self._is_immutable = is_immutable
        self._closed = False

    def readat(self, num_bytes, offset):
        if self._closed:
          raise FileClosedError("File handle is closed.")
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self._closed:
          raise FileClosedError("File handle is closed.")
        if self._is_immutable:
          raise FileInUseError("Cannot write to an older, immutable file version.")
        return self.VMfile.writeat(data, offset)

    def close(self):
        if self._closed:
          try:
              return self.VMfile.close()
          except FileClosedError:
              return None

        retval = self.VMfile.close()
        self._closed = True

        file_versions_lock.acquire(True) # Use blocking acquire
        try:
          if self._basename in file_versions:
             if file_versions[self._basename]['open_handle'] is self.VMfile:
                 file_versions[self._basename]['open_handle'] = None
        finally:
          file_versions_lock.release()
        return retval

    # Destructor: Best-effort cleanup if close() wasn't called explicitly.
    def __del__(self):
        # Check attributes exist before accessing, important during shutdown
        if hasattr(self, '_closed') and not self._closed and hasattr(self, 'VMfile') and self.VMfile:
            try:
                # Check if lock exists before trying to acquire/release
                if file_versions_lock:
                   self.close()
            except Exception:
                pass # Suppress GC errors


# --- Security Layer Functions (Logic Providers) ---
def LPopenfile(filename, create):
  # No 'import re' needed here

  if "/" in filename or "\\" in filename:
      raise RepyArgumentError("Invalid characters (path separators) in filename.")

  # Use string parsing helper instead of regex match
  basename_parsed, version_num_parsed = _parse_version_filename(filename)
  is_explicit_version = (basename_parsed is not None)

  if is_explicit_version:
    basename = basename_parsed
    version_num = version_num_parsed
    if create:
      raise RepyArgumentError("Cannot create explicit version files using '.vN' syntax.")
    else:
      try:
        underlying_fo = openfile(filename, False)
        # Pass underlying_fo and metadata to VMFile constructor
        return VMFile(underlying_fo, basename, version_num, True) # Immutable
      except FileNotFoundError:
        raise FileNotFoundError("Specific file version not found: " + filename)

  # --- Accessing via Base Filename ---
  basename = filename
  file_versions_lock.acquire(True) # Use blocking acquire
  try:
    latest_num, open_handle = _get_latest_version_info(basename)
    latest_filename = _get_versioned_filename(basename, latest_num)

    if create:
      # Use underlying listfiles for existence check if state isn't populated
      exists = (latest_num > 0) or (basename in file_versions)
      if not exists and basename not in file_versions:
           # Check actual file system using underlying listfiles()
           # Need to ensure listfiles() here IS the underlying one.
           # Encasementlib usually provides access or context switching.
           # Assuming listfiles() IS the underlying one in this context for now.
           if basename in listfiles():
               exists = True
           # If _get_latest_version_info could modify state based on scan, re-check might be needed
           # The current _get_latest_version_info does update state after scanning.

      if not exists:
        underlying_fo = openfile(basename, True)
        # Update state only if not already done by _get_latest_version_info
        if basename not in file_versions:
            file_versions[basename] = {'latest': 0, 'open_handle': None}
        file_versions[basename]['open_handle'] = underlying_fo # Set handle anyway
        # Pass underlying_fo and metadata to VMFile constructor
        return VMFile(underlying_fo, basename, 0, False) # Mutable
      else:
        # Re-fetch state in case _get_latest_version_info updated it
        # This might be redundant if _get_latest_version_info guarantees update
        latest_num, open_handle = file_versions[basename]['latest'], file_versions[basename]['open_handle']
        latest_filename = _get_versioned_filename(basename, latest_num)

        if open_handle is not None:
            raise FileInUseError("Cannot create a new version while the latest version ('" + latest_filename + "') is still open.")

        new_version_num = latest_num + 1
        new_filename = _get_versioned_filename(basename, new_version_num)

        try:
          # Open previous latest using underlying openfile
          prev_file = openfile(latest_filename, False)
          content = prev_file.readat(None, 0)
          prev_file.close()

          # Create new version using underlying openfile
          new_underlying_fo = openfile(new_filename, True)
          new_underlying_fo.writeat(content, 0)

          # Update state
          file_versions[basename]['latest'] = new_version_num
          file_versions[basename]['open_handle'] = new_underlying_fo

          # Pass underlying_fo and metadata to VMFile constructor
          return VMFile(new_underlying_fo, basename, new_version_num, False) # Mutable

        except FileNotFoundError:
            # _handle_internalerror relies on tracebackrepy being available
            # Use log + exitall as fallback
            log("FATAL: Inconsistent state: Latest version file '" + latest_filename + "' not found during copy.\n")
            exitall() # Use exitall if _handle_internalerror isn't available
            raise InternalRepyError("State inconsistency")
        except Exception, e:
             raise RepyException("Error creating new version '" + new_filename + "': " + str(e))
    else: # create=False
      exists = (latest_num > 0) or (basename in file_versions)
      if not exists and basename not in file_versions:
           if basename in listfiles(): # Check actual underlying listfiles
                exists = True
           # Consider if _get_latest_version_info needs update based on listfiles scan

      if not exists:
        raise FileNotFoundError("File not found: " + basename)

      try:
        # Open latest using underlying openfile
        underlying_fo = openfile(latest_filename, False)
        # Pass underlying_fo and metadata to VMFile constructor
        return VMFile(underlying_fo, basename, latest_num, True) # Immutable
      except FileNotFoundError:
           log("FATAL: Inconsistent state: Latest version file '" + latest_filename + "' not found when opening.\n")
           exitall() # Use exitall if _handle_internalerror isn't available
           raise InternalRepyError("State inconsistency")
  finally:
    file_versions_lock.release()

def LPremovefile(filename):
    raise RepyArgumentError("File deletion is not allowed by the security layer.")

def LPlistfiles():
    # No 'import re' needed here anymore

    # Assuming listfiles() here calls the underlying Repy API listfiles
    all_files = listfiles()
    # Use helper function for filtering
    base_files = []
    for f in all_files:
        if not _is_version_file(f):
            base_files.append(f)
    return base_files


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()