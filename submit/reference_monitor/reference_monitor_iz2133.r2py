"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

if 'file_versions' not in mycontext:
    mycontext['file_versions'] = {}
    mycontext['open_files'] = set()

def _get_version_name(basename, version_num):
    if version_num == 0:
        return basename
    else:
        return basename + ".v" + str(version_num)

def is_valid_filename(filename):
    if len(filename) > 120:
        return False
    if not filename or filename.startswith('.') or filename in ('.', '..'):
        return False
    for char in filename:
        if not ('a' <= char <= 'z' or '0' <= char <= '9' or char in '.-_'):
            return False
    return True

def _split_version_from_filename(filename):
  return filename.rsplit('.v', 1)

if 'file_op_lock' not in mycontext:
    mycontext['file_op_lock'] = createlock()


class VMFile():
    def __init__(self, file_handle, real_filename, is_latest):
        self.VMfile = file_handle
        self.real_filename = real_filename
        self.is_latest = is_latest
        mycontext['open_files'].add(self.real_filename)

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if not self.is_latest:
            raise FileInUseError("Cannot write to an older file version")
        return self.VMfile.writeat(data, offset)

    def close(self):
        mycontext['file_op_lock'].acquire(True)
        try:
            if self.real_filename in mycontext['open_files']:
                mycontext['open_files'].remove(self.real_filename)
        finally:
            mycontext['file_op_lock'].release()
        return self.VMfile.close()


def LPopenfile(filename, create):
    base_part = _split_version_from_filename(filename)[0]
    if not is_valid_filename(base_part):
        raise RepyArgumentError("Invalid characters in " + filename)

    mycontext['file_op_lock'].acquire(True)
    try:
        parts = _split_version_from_filename(filename)
        is_explicit_version = len(parts) == 2 and parts[1].isdigit()

        if is_explicit_version:
            if create:
                raise RepyArgumentError("Cannot create explicit version files manually")
            basename = parts[0]
            version_num = int(parts[1])
            latest_version = mycontext['file_versions'].get(basename, -1)
            is_latest = (version_num == latest_version)

            handle = openfile(filename, False)
            return VMFile(handle, filename, is_latest)

        basename = filename
        if create:
            if basename in mycontext['file_versions']:
                latest_version_num = mycontext['file_versions'][basename]
                latest_filename = _get_version_name(basename, latest_version_num)

                new_version_num = latest_version_num + 1
                new_filename = _get_version_name(basename, new_version_num)

            new_handle = None
            try:
                prev_file = openfile(latest_filename, False)
                content = prev_file.readat(None, 0)
                prev_file.close()
                
                new_handle = openfile(new_filename, True)
                new_handle.writeat(content, 0)
                
                mycontext['file_versions'][basename] = new_version_num
                return VMFile(new_handle, new_filename, True)
            except Exception, e:
                if new_handle:
                    new_handle.close()
                if new_filename in listfiles():
                    removefile(new_filename)
                raise e

            else:
                mycontext['file_versions'][basename] = 0
                handle = openfile(basename, True)
                return VMFile(handle, basename, True)
        else:
            if basename not in mycontext['file_versions']:
                raise FileNotFoundError("File " + basename + " does not exist")
            latest_version_num = mycontext['file_versions'][basename]
            latest_filename = _get_version_name(basename, latest_version_num)
            handle = openfile(latest_filename, False)
            return VMFile(handle, latest_filename, True)
    finally:
        mycontext['file_op_lock'].release()


def LPremovefile(filename):
    raise RepyArgumentError("File deletion not allowed")

def LPlistfiles():
    base_files = set()
    for fname in listfiles():
        parts = _split_version_from_filename(fname)
        if len(parts) == 2 and parts[1].isdigit():
            base_files.add(parts[0])
        else:
            base_files.add(fname)
    return list(base_files)



# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()