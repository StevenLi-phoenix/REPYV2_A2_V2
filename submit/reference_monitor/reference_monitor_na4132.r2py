"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

# Global state tracking
OPEN_FILES = {}  # Track open files: {filename: file_handle}

def _validate_filename(filename):
    """Validate filename for security threats"""
    if not isinstance(filename, str):
        raise RepyArgumentError("Filename must be a string")

    if len(filename) == 0:
        raise RepyArgumentError("Filename cannot be empty")

    if len(filename) > 255:
        raise RepyArgumentError("Filename too long")

    # Prevent path traversal attacks
    if '..' in filename or '/' in filename or '\\' in filename:
        raise RepyArgumentError("Invalid filename: path separators not allowed")

    # Prevent null bytes
    if '\x00' in filename:
        raise RepyArgumentError("Invalid filename: null bytes not allowed")

    # Prevent control characters
    for char in filename:
        if ord(char) < 32 and char not in ['\t']:
            raise RepyArgumentError("Invalid filename: control characters not allowed")

    return True


class VMFile():
    def __init__(self, filename, create):
        # Validate filename for security
        _validate_filename(filename)

        self.filename = filename
        self.is_new_file = create
        self.is_version_file = self._is_version_file(filename)
        
        # Check for FileInUseError - check if latest version is open
        if create and filename in listfiles():
            # File exists, check if latest version is open
            latest_version = self._get_latest_version_filename(filename)
            if latest_version in OPEN_FILES:
                raise FileInUseError("Latest version is already open")
        elif filename in OPEN_FILES:
            raise FileInUseError("File is already open")
        
        # Handle version file access
        if self.is_version_file and create:
            raise RepyArgumentError("Cannot create explicit version files")
        
        # Register as open file
        OPEN_FILES[filename] = self
        
        if create:
            # Check if base file exists
            if filename in listfiles():
                # File exists → find next version number and create new version
                version_num = self._get_next_version_number(filename)
                new_name = filename + ".v" + str(version_num)

                # Update filename to the new version
                self.filename = new_name
                OPEN_FILES[new_name] = OPEN_FILES.pop(filename)  # Update tracking

                # Copy content from latest version to new version efficiently
                latest_version_file = self._get_latest_version_filename(filename)
                prev_file = openfile(latest_version_file, False)
                self.VMfile = openfile(new_name, True)

                # Copy in chunks to avoid loading entire file into memory
                chunk_size = 4096
                offset = 0
                while True:
                    chunk = prev_file.readat(chunk_size, offset)
                    if len(chunk) == 0:
                        break
                    self.VMfile.writeat(chunk, offset)
                    offset += len(chunk)

                prev_file.close()
            else:
                # File doesn't exist → create base filename
                self.VMfile = openfile(filename, True)
        else:
            # Open existing file normally
            self.VMfile = openfile(filename, False)
    
    def _is_version_file(self, filename):
        # Check if filename ends with .v followed by digits
        if '.v' not in filename:
            return False
        parts = filename.split('.v')
        if len(parts) != 2:
            return False
        # Check if the part after .v is all digits
        version_part = parts[1]
        return version_part.isdigit()
    
    def _get_next_version_number(self, filename):
        """Find the next available version number for a file"""
        existing_files = listfiles()
        max_version = 0

        # Look for existing version files (filename.v1, filename.v2, etc.)
        for file in existing_files:
            if file.startswith(filename + ".v"):
                try:
                    version_part = file[len(filename) + 2:]  # Remove "filename.v"
                    version_num = int(version_part)
                    if version_num > max_version:
                        max_version = version_num
                except ValueError:
                    # Skip files that don't match version pattern
                    continue

        return max_version + 1

    def _get_latest_version_filename(self, filename):
        """Get the filename of the latest version (highest version number)"""
        existing_files = listfiles()
        max_version = 0
        latest_file = filename  # Default to base file if no versions exist

        # Look for existing version files (filename.v1, filename.v2, etc.)
        for file in existing_files:
            if file.startswith(filename + ".v"):
                try:
                    version_part = file[len(filename) + 2:]  # Remove "filename.v"
                    version_num = int(version_part)
                    if version_num > max_version:
                        max_version = version_num
                        latest_file = file
                except ValueError:
                    # Skip files that don't match version pattern
                    continue

        return latest_file

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        # Check if this is a version file (older version)
        if self.is_version_file:
            raise FileInUseError("Cannot write to older versions")

        # Check if this is an existing file opened for reading
        if not self.is_new_file:
            raise Exception("Cannot write to existing file - file system is immutable")

        return self.VMfile.writeat(data, offset)

    def close(self):
        # Remove from open files tracking
        if self.filename in OPEN_FILES:
            del OPEN_FILES[self.filename]
        return self.VMfile.close()


def LPopenfile(filename, create):
    # Validate filename for security
    _validate_filename(filename)

    # Check if trying to access version file
    if _is_version_file_static(filename):
        if create:
            raise RepyArgumentError("Cannot create explicit version files")
        # For reading version files, check if it exists
        if filename not in listfiles():
            raise FileNotFoundError("Version file does not exist")

    # For reading files, check if base file exists
    if not create and filename not in listfiles():
        raise FileNotFoundError("File does not exist")
    
    # Check for FileInUseError - check if latest version is open
    if create and filename in listfiles():
        # File exists, check if latest version is open
        latest_version = _get_latest_version_filename_static(filename)
        if latest_version in OPEN_FILES:
            raise FileInUseError("Latest version is already open")
    elif filename in OPEN_FILES:
        raise FileInUseError("File is already open")
    
    return VMFile(filename, create)

def LPremovefile(filename):
    # Validate filename for security
    _validate_filename(filename)

    # File deletion is completely forbidden
    raise RepyArgumentError("File deletion is not allowed in this security layer")

def LPlistfiles():
    all_files = listfiles()
    # Filter out version files (files ending with .v[number])
    base_files = []
    for file in all_files:
        if not _is_version_file_static(file):
            base_files.append(file)
    return base_files

def _is_version_file_static(filename):
    # Check if filename ends with .v followed by digits
    if '.v' not in filename:
        return False
    parts = filename.split('.v')
    if len(parts) != 2:
        return False
    # Check if the part after .v is all digits
    version_part = parts[1]
    return version_part.isdigit()

def _get_latest_version_filename_static(filename):
    """Get the filename of the latest version (highest version number)"""
    existing_files = listfiles()
    max_version = 0
    latest_file = filename  # Default to base file if no versions exist

    # Look for existing version files (filename.v1, filename.v2, etc.)
    for file in existing_files:
        if file.startswith(filename + ".v"):
            try:
                version_part = file[len(filename) + 2:]  # Remove "filename.v"
                version_num = int(version_part)
                if version_num > max_version:
                    max_version = version_num
                    latest_file = file
            except ValueError:
                # Skip files that don't match version pattern
                continue

    return latest_file


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()