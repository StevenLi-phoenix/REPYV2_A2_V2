"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

#tracking all open files-
open_files = []
writable_files = []

# === Helper Functions ===
def _get_versions(filename):
    """Return sorted list of version numbers for a given base filename."""
    files = listfiles()
    versions = []
    for f in files:
        if f.startswith(filename + ".v"):
            try:
                versions.append(int(f.split(".v")[1]))
            except:
                pass
    versions.sort()
    return versions

def _get_latest_version_name(filename):
    """Return name of latest version file or None if none exist."""
    versions = _get_versions(filename)
    if versions:
        return filename + ".v" + str(versions[-1])
    elif filename in listfiles():
        return filename
    else:
        return None
def _is_explicit_version_name(filename):
    # an explicit version name ends with .v
    if ".v" not in filename:
        return False
    base, suffix = filename.rsplit(".v", 1)
    return suffix.isdigit() and base != ""

class VMFile():
    def __init__(self, filename, create, is_version=False):
        self.filename = filename
        self.is_version = is_version
        self.is_versioned = _is_explicit_version_name(filename)
        self.writable = False
        # If explicit version and create=True then not allowed
        if self.is_versioned and create:
            raise RepyArgumentError("Cannot create explicit version files")
        if not is_version and create:
            files = listfiles()
            versions = _get_versions(filename)
            #create a new version
            if filename in files or (len(versions) > 0):
                latest_name = _get_latest_version_name(filename)
                #check if it is open
                if latest_name in open_files:
                    raise FileInUseError("Cannot create a new version while previous version is open")
                next_version = len(versions) + 1
                new_name = filename + ".v" + str(next_version)
                prev_file = openfile(latest_name, False)
                new_file = openfile(new_name, True)

                offset = 0
                chunk_size = 65536
                while True:
                    data = prev_file.readat(chunk_size, offset)
                    if not data:
                        break
                    new_file.writeat(data, offset)
                    offset += len(data)

                prev_file.close()
                self.VMfile = new_file
                self.filename = new_name
            else:
                # No prior versions just create base file
                self.VMfile = openfile(filename, True)
        else:
            #normal open
            self.VMfile = openfile(filename, create)

        open_files.append(self.filename)
        self.writable = (self.filename in writable_files)

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        # Prevent writing to any old version (immutable)
        if not self.writable:
          raise FileInUseError("Cannot write to immutable version")
        return self.VMfile.writeat(data, offset)

    def close(self):
        if self.filename in writable_files:
            try:
                writable_files.remove(self.filename)
            except:
                pass

    # Remove from open_files
        if self.filename in open_files:
            try:
                open_files.remove(self.filename)
            except:
                pass
        self.writable = False

        return self.VMfile.close()


def LPopenfile(filename, create):
    latest_name = _get_latest_version_name(filename)
    if (filename in open_files) or (latest_name and latest_name in open_files):
        raise FileInUseError("File already open")
    vm = VMFile(filename, create, (filename.find(".v") != -1))
    # Explicit version access allowed only if create=False
    if create:
        if vm.filename not in writable_files:
            writable_files.append(vm.filename)
        vm.writable = True
    else:
        vm.writable = False
    return vm

def LPremovefile(filename):
    raise RepyArgumentError("File deletion not allowed")

def LPlistfiles():
    files = listfiles()
    visible = []
    for f in files:
        if f.find(".v") != -1:
            parts = f.split(".v")
            base = parts[0]
            if base not in visible:
                visible.append(base)
        else:
            if f not in visible:
                visible.append(f)
    return visible

# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()