```"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"


class VMFile():
    # Class-level tracking for open files
    open_files = {}
    
    def __init__(self, filename, create):
        self.filename = filename
        self.VMfile = None
        self.is_writable = True
        self.base_filename = None
        
        # Validate filename format
        if not self._is_valid_filename(filename):
            raise ValueError("Invalid filename")

        # RULE 5: Cannot manually create any file with .v pattern
        # This blocks both valid version files (.v1, .v2) and invalid ones (.v0, .v00, etc)
        if create and '.v' in filename:
            # Check if it looks like a version file pattern
            parts = filename.split('.v')
            if len(parts) == 2 and parts[1]:
                # Check if version part is all digits
                is_digit_suffix = True
                for char in parts[1]:
                    if char not in '0123456789':
                        is_digit_suffix = False
                        break
                if is_digit_suffix:
                    raise RepyArgumentError("Cannot create explicit version files")

        # Determine if this is a version file
        is_version = self._is_version_file(filename)

        if is_version:
            base_name = self._extract_base_filename(filename)
        else:
            base_name = filename

        self.base_filename = base_name
        
        # RULE 4: Check if file is already open
        if base_name in VMFile.open_files:
            raise FileInUseError("File is already open")
        
        # CASE 1: Opening an existing version file (read-only)
        if is_version:
            # RULE 6: Version must exist
            if filename not in listfiles():
                raise FileNotFoundError("Version file does not exist")
            
            # RULE 7: Old versions are read-only
            self.VMfile = openfile(filename, False)
            self.is_writable = False
            VMFile.open_files[base_name] = self
            return
        
        # CASE 2: Creating new version (file exists + create=True)
        if filename in listfiles() and create:
            # Find highest version number
            highest_version = self._find_highest_version(base_name)

            # Prevent version number overflow
            if highest_version >= 999999:
                raise RepyArgumentError("Maximum version limit reached")

            # Determine source to copy from
            if highest_version == 0:
                source_filename = base_name
            else:
                source_filename = base_name + ".v" + str(highest_version)

            # Copy content from source
            source = openfile(source_filename, False)
            content = source.readat(None, 0)
            source.close()

            # Create new version
            new_version = highest_version + 1
            new_filename = base_name + ".v" + str(new_version)

            self.VMfile = openfile(new_filename, True)
            if content:
                self.VMfile.writeat(content, 0)

            self.is_writable = True
            VMFile.open_files[base_name] = self
            return
        
        # CASE 3: Normal create or open
        self.VMfile = openfile(filename, create)
        self.is_writable = True
        VMFile.open_files[base_name] = self
    
    def _is_valid_filename(self, filename):
        """Validate filename according to Repy specifications"""
        if not filename or filename == '.' or filename == '..':
            return False
        if filename.startswith('.'):
            return False
        if len(filename) > 120:
            return False
        
        valid_chars = 'abcdefghijklmnopqrstuvwxyz0123456789-_.'
        for char in filename:
            if char not in valid_chars:
                return False
        
        return True
    
    def _is_version_file(self, filename):
        """Check if filename is a version file (format: basename.vN)"""
        # Must contain exactly one '.v' substring
        if filename.count('.v') != 1:
            return False

        # Split on '.v' - should give exactly 2 parts
        parts = filename.split('.v')
        if len(parts) != 2:
            return False

        base_part = parts[0]
        version_part = parts[1]

        # Both parts must be non-empty
        if not base_part or not version_part:
            return False

        # Version part must be all digits
        for char in version_part:
            if char not in '0123456789':
                return False

        try:
            ver_num = int(version_part)
            # Must be positive (>= 1), no leading zeros
            if ver_num < 1:
                return False
            # Check for leading zeros: "01" != "1"
            if version_part != str(ver_num):
                return False
            return True
        except:
            return False
    
    def _extract_base_filename(self, filename):
        """Extract base filename from version file"""
        if not self._is_version_file(filename):
            return filename
        return filename.split('.v')[0]
    
    def _find_highest_version(self, base_filename):
        """Find highest version number for a base file"""
        all_files = listfiles()
        max_version = 0

        for f in all_files:
            # Check if it's a valid version file first
            if self._is_version_file(f):
                # Then verify the base filename matches exactly
                if self._extract_base_filename(f) == base_filename:
                    version_str = f.split('.v')[1]
                    try:
                        ver_num = int(version_str)
                        # Add sanity check for reasonable version numbers
                        if ver_num > 0 and ver_num < 1000000:
                            if ver_num > max_version:
                                max_version = ver_num
                    except:
                        pass

        return max_version

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        # RULE 7: Cannot write to old versions
        if not self.is_writable:
            raise FileInUseError("Cannot write to old version")
        return self.VMfile.writeat(data, offset)

    def close(self):
        result = self.VMfile.close()
        
        # Remove from tracking
        if self.base_filename in VMFile.open_files:
            del VMFile.open_files[self.base_filename]
        
        return result


def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    # RULE 8: File deletion not allowed
    raise RepyArgumentError("File deletion is not allowed")

def LPlistfiles():
    # RULE 9: Hide version files from listing
    all_files = listfiles()
    # Create a completely new list to avoid type issues
    filtered = []
    seen_files = {}

    for filename in all_files:
        # Inline check if this is a valid version file
        is_version_file = False
        base_name = str(filename)  # Force string type

        if filename.count('.v') == 1:
            file_parts = filename.split('.v')
            if len(file_parts) == 2:
                name_part = file_parts[0]
                num_part = file_parts[1]

                if name_part and num_part:
                    # Check if version part is all digits
                    all_digits = True
                    for c in num_part:
                        if c not in '0123456789':
                            all_digits = False
                            break

                    if all_digits:
                        try:
                            version_number = int(num_part)
                            # Must be positive (>= 1), no leading zeros
                            if version_number >= 1 and num_part == str(version_number):
                                is_version_file = True
                                base_name = str(name_part)
                        except:
                            pass

        # Add base filename if not already seen
        if base_name not in seen_files:
            filtered.append(str(base_name))
            seen_files[base_name] = True

    return filtered


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()```