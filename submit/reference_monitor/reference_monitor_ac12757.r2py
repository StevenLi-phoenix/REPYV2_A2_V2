
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

current_file_versions = {}
open_files = {}




def _get_version(filename):
    if '.v' in filename:
        parts = filename.rsplit('.v', 1)
        if len(parts) == 2 and parts[1].isdigit():
            original_name = parts[0]
            version_num = int(parts[1])
            if version_num > 0:
                return (original_name, version_num, True)
    return (filename, 0, False)

def _get_full_version(original_filename, version_number):
    if version_number == 0:
        return original_filename
    return original_filename + ".v" + str(version_number)


class VMFile(object):
    def __init__(self, original_filename, version_number, is_writable_instance, repy_file_object):
        self.original_filename = original_filename
        self.version_number = version_number
        self.is_writable_instance = is_writable_instance
        self.repy_file_object = repy_file_object
        open_files[self.repy_file_object] = (original_filename, version_number, is_writable_instance)

    def readat(self, num_bytes, offset):

        try:
            return self.repy_file_object.readat(num_bytes, offset)
        except Exception:
            raise

    def writeat(self, data, offset):

        if not self.is_writable_instance:
            raise FileInUseError("Attempted to write to an immutable file version.")
        
        try:
            return self.repy_file_object.writeat(data, offset)
        except Exception:
            raise

    def close(self):

        try:
            self.repy_file_object.close()
        except Exception:
            raise
        finally:
            if self.repy_file_object in open_files:
                del open_files[self.repy_file_object]
        return None




def LPopenfile(filename, create):

    original_name, requested_version_num, is_explicit = _get_version(filename)

    if create and is_explicit:
        raise RepyArgumentError("Cannot create explicit version files ")

    for repy_f_obj, (open_orig_name, open_ver_num, _) in open_files.items():
        if open_orig_name == original_name:
            if create and open_ver_num == current_file_versions.get(original_name, 0):
                raise FileInUseError("Cannot create a new version while the latest version")
            elif not create and _get_full_version(open_orig_name, open_ver_num) == filename:
                raise FileInUseError("File is already open.")

    if create:
        if original_name not in current_file_versions:
            repy_f_obj = openfile(original_name, True)
            current_file_versions[original_name] = 0
            return VMFile(original_name, 0, True, repy_f_obj)
        else:
            latest_version_num = current_file_versions[original_name]
            source_filename = _get_full_version(original_name, latest_version_num)
            try:
                source_repy_f = openfile(source_filename, False)
                content = source_repy_f.readat(None, 0)
                source_repy_f.close()
            except FileNotFoundError:
                raise Exception(" Latest version file not found for copying: ")
            except Exception:
                raise
            new_version_num = latest_version_num + 1
            new_full_filename = _get_full_version(original_name, new_version_num)
            repy_f_obj = openfile(new_full_filename, True)
            repy_f_obj.writeat(content, 0)
            current_file_versions[original_name] = new_version_num
            return VMFile(original_name, new_version_num, True, repy_f_obj)
    else:
        if original_name not in current_file_versions:
            raise FileNotFoundError("File not found: " + original_name)
        if not is_explicit:
            try:
                repy_f_obj = openfile(original_name, False)
            except FileNotFoundError:
                 raise FileNotFoundError(" base file not found  ")
            return VMFile(original_name, 0, False, repy_f_obj)
        else:
            if requested_version_num > current_file_versions[original_name]:
                raise FileNotFoundError("Version not found.")
            try:
                repy_f_obj = openfile(filename, False)
            except FileNotFoundError:
                 raise FileNotFoundError(" version file not found: ")
            return VMFile(original_name, requested_version_num, False, repy_f_obj)

def LPremovefile(filename):
    raise RepyArgumentError("File deletion is not allowed for any file.")

def LPlistfiles():
   
   
    return current_file_versions.keys()


# --- Boilerplate (DO NOT CHANGE BELOW THIS POINT) ---
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}
CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile,
}
CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile,
}
CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles,
}
secure_dispatch_module()
