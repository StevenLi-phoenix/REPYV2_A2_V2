
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"


USER_FILES = []

class VMFile():
    def __init__(self, filename, create):
        self.is_readonly = False

        # --- Rule 1: Explicit version creation not allowed ---
        if ".v" in filename and create:
            raise RepyArgumentError("Cannot create explicit version files")

        # --- Rule 2: Validate allowed characters ---
        if create:
            for ch in filename:
                if not (ch.islower() or ch.isdigit()):
                    raise RepyArgumentError("Special symbols not allowed in filename")

        existing_files = listfiles()

        # --- CREATE NEW FILE / VERSION ---
        if create:
            # Determine existing highest version
            version_num = 0
            for f in existing_files:
                if f.startswith(filename + ".v"):
                    try:
                        num = int(f.split(".v")[1])
                        if num > version_num:
                            version_num = num
                    except:
                        continue

            # Determine new version name
            new_version_num = version_num + 1
            new_name = filename + ".v" + str(new_version_num)

            # If previous version exists, copy its contents
            if version_num > 0:
                latest_version = filename + ".v" + str(version_num)
                try:
                    prev_file = openfile(latest_version, False)
                except FileInUseError:
                    raise FileInUseError("Cannot create new version while latest version is open")
                content = prev_file.readat(None, 0)
                prev_file.close()

                self.VMfile = openfile(new_name, True)
                self.VMfile.writeat(content, 0)
            else:
                # First version (no prior file)
                self.VMfile = openfile(new_name, True)

            # Register base filename for tracking
            _register_user_file(filename)

        # --- OPEN EXISTING FILE ---
        else:
            # Explicit version name
            if ".v" in filename:
                if filename not in existing_files:
                    raise FileNotFoundError("Versioned file does not exist")
                
                # Extract base filename and version number
                base_name = filename.split(".v")[0]
                
                # Find the latest version number for this base file
                version_nums = []
                for f in existing_files:
                    if f.startswith(base_name + ".v"):
                        try:
                            num = int(f.split(".v")[1])
                            version_nums.append(num)
                        except:
                            continue
                
                # Open the file
                self.VMfile = openfile(filename, False)
                
                # Allow writes only if this is the latest version
                if version_nums:
                    latest_version_num = max(version_nums)
                    current_version_num = int(filename.split(".v")[1])
                    
                    if current_version_num == latest_version_num:
                        self.is_readonly = False  # latest version = writable
                    else:
                        self.is_readonly = True  # older versions = read-only
                else:
                    self.is_readonly = True

            # Base filename (open latest version)
            else:
                version_nums = []
                for f in existing_files:
                    if f.startswith(filename + ".v"):
                        try:
                            num = int(f.split(".v")[1])
                            version_nums.append(num)
                        except:
                            continue

                if not version_nums:
                    raise FileNotFoundError("File does not exist")

                latest_version = filename + ".v" + str(max(version_nums))
                self.VMfile = openfile(latest_version, False)

    # --- STANDARD FILE METHODS ---
    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self.is_readonly:
            raise FileInUseError("Cannot write to read-only version files")
        return self.VMfile.writeat(data, offset)

    def close(self):
        return self.VMfile.close()


# --- INTERNAL FILE TRACKING ---
def _register_user_file(filename):
    # Track user-created files in memory
    if filename not in USER_FILES:
        USER_FILES.append(filename)


# --- STANDARD INTERFACE METHODS ---
def LPopenfile(filename, create):
    return VMFile(filename, create)


def LPremovefile(filename):
    # No file deletion allowed
    raise RepyArgumentError("File deletion not allowed")


def LPlistfiles():
    # Get all actual files from the file system
    current_files = set(listfiles())
    
    # Filter to return only user-created base filenames that still have versions
    base_files = []
    
    for f in USER_FILES:
        # Check if any version of this file exists
        exists = False
        for cf in current_files:
            if cf.startswith(f + ".v") or cf == f:
                exists = True
                break
        if exists:
            base_files.append(f)
    
    return list(base_files)




# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()