"""
This security layer handles the Versioned and Immutable functionality
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

open_files = {}
write_files = {}

def _is_version_name(name):
    idx = name.rfind(".v")
    if idx == -1:
        return False
    base = name[:idx]
    tail = name[idx+2:]
    if base == "":
        return False
    if tail == "":
        return False
    for ch in tail:
        if ch < "0" or ch > "9":
            return False
    return True

def _extract_base_and_version(name):
    idx = name.rfind(".v")
    if idx == -1:
        return (name, None)
    base = name[:idx]
    tail = name[idx+2:]
    if tail == "":
        return (name, None)
    for ch in tail:
        if ch < "0" or ch > "9":
            return (name, None)
    try:
        return (base, int(tail))
    except Exception:
        return (name, None)

def LPlistfiles():
    files = listfiles()
    keep = []
    for f in files:
        _, num = _extract_base_and_version(f)
        if num is None:
            keep.append(f)
    return keep

def _highest_version_for(filename):
    maxn = 0
    flist = listfiles()
    prefix = filename + ".v"
    plen = len(prefix)
    for f in flist:
        if len(f) <= plen:
            continue
        if f[:plen] != prefix:
            continue
        tail = f[plen:]
        ok = True
        for ch in tail:
            if ch < "0" or ch > "9":
                ok = False
                break
        if not ok:
            continue
        try:
            n = int(tail)
            if n > maxn:
                maxn = n
        except Exception:
            continue
    return maxn

def _copy_file_content(src_name, dst_name):
    CHUNK_SIZE = 4096
    src = openfile(src_name, False)
    dst = openfile(dst_name, True)

    offset = 0
    while True:
        data = src.readat(CHUNK_SIZE, offset)
        if not data:
            break
        dst.writeat(data, offset)
        offset += len(data)

    src.close()
    dst.close()

class VMFile(object):
    def __init__(self, filename, create=False):
        self.filename = filename
        self.is_version = _is_version_name(filename)
        self._file = None

        if create and self.is_version:
            raise RepyArgumentError("Cannot create explicit version files")

        if create and (not self.is_version):
            if filename in open_files:
                raise FileInUseError("File is already open")
            flist = listfiles()
            
            if filename in flist:
                next_n = _highest_version_for(filename) + 1
                version_name = filename + ".v" + str(next_n)
                _copy_file_content(filename, version_name)
                self._file = openfile(filename, True)
                self.is_version = False
            else:
                self._file = openfile(filename, True)
                self.is_version = False
            
            open_files[filename] = True
        else:
            if self.is_version:
                flist = listfiles()
                if filename not in flist:
                    raise FileNotFoundError("File does not exist")
            
            self._file = openfile(filename, False)
            self.is_version = _is_version_name(filename)

    def readat(self, num_bytes, offset):
        return self._file.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self.is_version:
            raise FileInUseError("Cannot write to versioned file")
        if self.filename in write_files:
            raise FileInUseError("File already being written")
        write_files[self.filename] = True
        try:
            return self._file.writeat(data, offset)
        finally:
            if self.filename in write_files:
                del write_files[self.filename]

    def close(self):
        result = self._file.close()
        if self.filename in open_files:
            del open_files[self.filename]
        return result


def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    if _is_version_name(filename):
        raise RepyArgumentError("Cannot remove versioned file")
    raise RepyArgumentError("Cannot remove files")


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()