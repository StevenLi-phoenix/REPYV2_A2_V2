"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"
file_version_map = {}


class VMFile():
    

    def __init__(self, filename, create):

        populate_file_version_map()
  
        if create:
            if is_file_name_with_version(filename):
                raise RepyArgumentError("Cannot create explicit version files")
            else:
                if filename in listfiles():
                    try:
                        latest_version = file_version_map[filename]
                    except KeyError:
                        raise FileNotFoundError("File not found")
                    if latest_version == 0:
                        prev_file_name = filename
                    else:
                        prev_file_name = filename + ".v" + str(latest_version)

                    prev_file = openfile(prev_file_name, False)
                    content = prev_file.readat(None, 0)
                    prev_file.close()

                    new_version = latest_version + 1
                    new_name = filename + ".v" + str(new_version)

                    try:
                        prev_file = openfile(prev_file_name, False)
                        prev_file.close()
                    except FileInUseError:
                        raise FileInUseError("File in use")
                    self.fname = new_name
                    self.fversion = new_version
                    self.VMfile = openfile(new_name, True)
                    self.VMfile.writeat(content, 0)
                    update_map(filename, new_version)
                    
                else:
                    self.fname = filename
                    self.fversion = 0
                    self.VMfile = openfile(filename, True)
                    update_map(filename, 0)
        else:
            try:
                if filename in listfiles():
                    if is_file_name_with_version(filename):
                        fn, ver = extract_name_and_version(filename)
                        latest_version = file_version_map[fn]
                        if ver > latest_version:
                            raise FileNotFoundError("No file found")
                    else:
                        ver = file_version_map[filename]
                    self.fname = filename
                    self.VMfile = openfile(filename, False)
                else:
                    raise FileNotFoundError("No file found")
            except KeyError:
                raise FileNotFoundError("File not found")

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if is_file_name_with_version(self.fname):
            fn, ver = extract_name_and_version(self.fname)
        else: 
            fn, ver = self.fname, 0
        latest_version = file_version_map[fn]
        if ver < latest_version:
            raise FileInUseError("File in use")
        return self.VMfile.writeat(data, offset)

    def close(self):
        return self.VMfile.close()

def populate_file_version_map():
    listOfFiles = listfiles()
    for file in listOfFiles:
        fn, version = extract_name_and_version(file)
        if fn in file_version_map:
            existing_version = file_version_map[fn]
            if existing_version < version:
                file_version_map[fn] = version
        else:
            file_version_map[fn] = version

def update_map(filename, version):
    file_version_map[filename] = version

def is_file_name_with_version(file_name):
    split_file_name = file_name.rsplit(".v", 1)
    if len(split_file_name) == 1:
        return False
    version = split_file_name[1]
    name = split_file_name[0]
    if not version or version[0] == '0' or not version.isdigit():
        return False
    if not name or name.isspace() or not name.strip():
        return False
    return True


def extract_name_and_version(file_name):
    fn= file_name
    fversion = 0
    if is_file_name_with_version(file_name):
        fn, ver = file_name.rsplit(".v", 1)
        fversion = int(ver)
    return fn, fversion

def LPopenfile(filename, create):
    return VMFile(filename, create)

def LPremovefile(filename):
    raise RepyArgumentError("Cannot delete file")

def LPlistfiles():
    listOfFiles = listfiles()
    new_list = []
    for item in listOfFiles:
        result = is_file_name_with_version(item)
        if  result == False:
            new_list.append(item)
    return new_list


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()