"""
==============================================================================
ATTACK CASE: hh2727_attackcase1.r2py
==============================================================================
Target NetID:        hh2727
Original Test:       test09_multiple_versions.r2py
Test File Path:      submit/general_tests/test09_multiple_versions.r2py

RUNNER INFORMATION:
  Runner ID:         runner-7206
  Task UUID:         7faa540d-9574-40c9-82b3-993d6ecab541
  Machine Type:      c2-standard-4
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:21:49.708004
  End Time:          2025-10-27T19:21:54.189621
  Runtime:           4.4816 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       c4a7892f5a4e580985ba9a538910fee2
  Attack MD5:        b705d0458f62c6142becb1b7dfc564ab
  Combined MD5:      cce39ef6bc42a69a76b089a97ac494a3

FAILURE DETAILS:
  Reason:            ERROR: Base file should remain unchanged


STDOUT:
  ERROR: Base file should remain unchanged

ORIGINAL TEST DESCRIPTION:
  Test 9: Multiple versions work correctly (v1, v2, v3, v4, v5)
  Verifies that multiple versions can be created and accessed

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: hh2727)
# ============================================================================
# """
# By Bob Huang / hh2727 / N10590703
# reference_monitor_hh2727.r2py
# 
# run: python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
#     
# Policy: files immutable after close.
# 
# 
# 
# """
# 
# REAL_openfile   = openfile
# REAL_removefile = removefile
# REAL_listfiles  = listfiles
# 
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"  
# OBJC = "objc"
# 
# 
# # keep file sample in memory
# _state = {}
# 
# 
# def ensure_entry(base_name):
#   if base_name not in _state:
#     _state[base_name] = {
#       'latest': 0,
#       'open': set(),
#       'writing': False
#     }
#   return _state[base_name]
# 
# def is_version(name):
#   if ".v" not in name:
#     return (False, None, None)
#   parts = name.split(".v")
#   if len(parts) != 2 or not parts[1].isdigit():
#     return (False, None, None)
#   base = parts[0]
#   if base == "":
#     return (False, None, None)
#   ver = int(parts[1])
#   if ver < 1:
#     return (False, None, None)
#   return (True, base, ver)
# 
# def base_exists(base):
#   for f in REAL_listfiles():
#     ok, b, v = is_version(f)
#     if f == base or (ok and b == base):
#       return True
#   return False
# 
# def read_all(f): return f.readat(None, 0)
# def write_all(f, d): return f.writeat(d, 0)
# 
# def copy_file(src, dst):
#   s = REAL_openfile(src, False)
#   data = read_all(s)
#   s.close()
#   write_all(dst, data)
# 
# # file object
# class VMFile(object):
#   def __init__(self, name, create):
#     if not name or name.startswith("."):
#       raise RepyArgumentError("bad name")
#     if len(name) > 120:
#       raise RepyArgumentError("too long")
# 
#     self.name = name
#     self.base = name
#     self.writable = False
#     self.version = None
# 
#     isv, base, ver = is_version(name)
#     if isv:
#       if create:
#         raise RepyArgumentError("can't create .vN directly")
#       self.base = base
#       meta = ensure_entry(base)
#       if name in meta["open"]:
#         raise FileInUseError("already open")
#       self.fh = REAL_openfile(name, False)
#       meta["open"].add(name)
#       return
# 
#     base = name
#     meta = ensure_entry(base)
# 
#     if create:
#       if meta["writing"]:
#         raise FileInUseError("another create open")
#       if base_exists(base):
#         meta["latest"] += 1
#         newv = meta["latest"]
#         self.fh = REAL_openfile(base, True)
#         prev = base + ".v" + str(newv - 1)
#         copy_file(prev, self.fh)
#         self.version = newv
#       else:
#         meta["latest"] = 1
#         self.fh = REAL_openfile(base, True)
#         self.version = 1
#       if base in meta["open"]:
#         raise FileInUseError("already open")
#       meta["open"].add(base)
#       meta["writing"] = True
#       self.writable = True
#       self.base = base
#       return
# 
#     if base in meta["open"]:
#       raise FileInUseError("already open")
#     if not base_exists(base):
#       raise FileNotFoundError("no such file")
#     self.fh = REAL_openfile(base, False)
#     meta["open"].add(base)
# 
#   def readat(self, n, off): return self.fh.readat(n, off)
# 
#   def writeat(self, d, off):
#     if not self.writable:
#       raise FileInUseError("immutable")
#     return self.fh.writeat(d, off)
# 
#   def close(self):
#     res = self.fh.close()
#     base = self.base
#     meta = ensure_entry(base)
#     if self.name in meta["open"]:
#       meta["open"].remove(self.name)
#     if self.writable and self.version:
#       snap = base + ".v" + str(self.version)
#       vfh = REAL_openfile(snap, True)
#       bfh = REAL_openfile(base, False)
#       write_all(vfh, read_all(bfh))
#       bfh.close()
#       vfh.close()
#       meta["writing"] = False
#     self.writable = False
#     self.version = None
#     return res
# 
# # wrappers
# def LPopenfile(name, create): return VMFile(name, create)
# def LPremovefile(name): raise RepyArgumentError("remove not allowed")
# 
# def LPlistfiles():
#   real = REAL_listfiles()
#   seen = set()
#   out = []
#   for f in real:
#     isv, base, ver = is_version(f)
#     if isv:
#       if base not in seen:
#         seen.add(base)
#         out.append(base)
#     else:
#       if f not in out:
#         out.append(f)
#   return out
# 
# # encasementlib defs
# sec_file_def = {
#   "obj-type": VMFile,
#   "name": "VMFile",
#   "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#   "readat":  {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#   "close":   {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#   "type": OBJC,
#   "args": (str, bool),
#   "exceptions": Exception,
#   "return": sec_file_def,
#   "target": LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#   "type": "func",
#   "args": (str,),
#   "exceptions": Exception,
#   "return": type(None),
#   "target": LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#   "type": "func",
#   "args": None,
#   "exceptions": Exception,
#   "return": list,
#   "target": LPlistfiles
# }
# 
# secure_dispatch_module()
# 
# 
# 
# 
# ============================================================================

f1 = openfile("testfile9", True)
f1.writeat("Base", 0)
f1.close()

# Create versions v1 through v5
for i in range(1, 6):
    fx = openfile("testfile9", True)
    content = fx.readat(None, 0)
    fx.writeat("V" + str(i), len(content))
    fx.close()

# Verify base file still has original content (immutable)
f2 = openfile("testfile9", False)
content = f2.readat(None, 0)
if content != "Base":
    log("ERROR: Base file should remain unchanged\n")
    exitall()
f2.close()

# Verify latest version (v5) has all accumulated content
f3 = openfile("testfile9.v5", False)
content = f3.readat(None, 0)
if "BaseV1V2V3V4V5" not in content:
    log("ERROR: Latest version should accumulate all changes\n")
    exitall()
f3.close()

