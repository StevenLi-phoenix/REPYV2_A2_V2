"""
==============================================================================
ATTACK CASE: sn3507_attackcase5.r2py
==============================================================================
Target NetID:        sn3507
Original Test:       test20_immutability_enforcement.r2py
Test File Path:      submit/general_tests/test20_immutability_enforcement.r2py

RUNNER INFORMATION:
  Runner ID:         runner-1167
  Task UUID:         eb0fe795-aa24-4cdd-b9ff-2a123635d71c
  Machine Type:      t3.medium
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:27:30.933199
  End Time:          2025-10-27T19:27:36.052490
  Runtime:           5.1193 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       a689e6aca26a9f993342c27c59f9dca1
  Attack MD5:        b2a8ad98a6911bcd1c0c5534521a675b
  Combined MD5:      7d3f6884ae04c6348ef1c2fde9eb769b

FAILURE DETAILS:
  Reason:            ERROR: Should not be able to write to old version


STDOUT:
  ERROR: Should not be able to write to old version

ORIGINAL TEST DESCRIPTION:
  Targets: sa9082, wjl9629, hl5031
  Vulnerability: Immutability not properly enforced across edge cases
  Attack: Test immutability with various file opening patterns and edge case names

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: sn3507)
# ============================================================================
# # Type and context definition constants
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"
# OBJC = "objc"
# 
# fileRegistry = []  # List of (filename, latest_version_number) tuples
# openHandles = []   # List of (file_object, filename, version_num, is_original) tuples
# 
# 
# class LPFile():
#     
#     def __init__(self, filename, create):
#         mycontext['debug'] = False
#         
#         # Parse filename to check if it's a versioned file request
#         baseName, versionNum = self.parseFilename(filename)
#         
#         # Validate versioned file creation attempts
#         if versionNum is not None and create:
#             raise RepyArgumentError("Cannot create explicit version files")
#         
#         # Handle file opening/creation logic
#         if versionNum is not None:
#             # Opening a specific version
#             self.openSpecificVersion(filename, baseName, versionNum, create)
#         else:
#             # Opening the original file
#             self.openOrCreateOriginal(filename, create)
#     
#     
#     def parseFilename(self, filename):
#         if '.v' in filename:
#             parts = filename.rsplit('.v', 1)
#             if len(parts) == 2 and parts[1].isdigit():
#                 return parts[0], int(parts[1])
#         return filename, None
#     
#     
#     def openSpecificVersion(self, fullFilename, baseName, versionNum, create):
#         # Check if the versioned file exists
#         fileList = listfiles()
#         fileExists = False
#         for existingFile in fileList:
#             if existingFile == fullFilename:
#                 fileExists = True
#                 break
#         
#         if not fileExists:
#             raise FileNotFoundError("File not found: " + fullFilename)
#         
#         # Open the versioned file
#         self.handle = openfile(fullFilename, False)
#         self.filename = fullFilename
#         self.baseName = baseName
#         self.versionNum = versionNum
#         self.isOriginal = False
#         
#         # Track this open handle
#         openHandles.append((self, fullFilename, versionNum, False))
#     
#     
#     def openOrCreateOriginal(self, filename, create):
#         fileList = listfiles()
#         fileExists = False
#         for existingFile in fileList:
#             if existingFile == filename:
#                 fileExists = True
#                 break
#         
#         if create and fileExists:
#             # Create a new version
#             self.createNewVersion(filename)
#         elif not create and not fileExists:
#             # Trying to open non-existent file without create flag
#             raise FileNotFoundError("File not found: " + filename)
#         else:
#             # Normal open or create
#             self.handle = openfile(filename, create)
#             self.filename = filename
#             self.baseName = filename
#             self.isOriginal = True
#             
#             # Initialize version tracking for new files
#             found = False
#             for i in range(len(fileRegistry)):
#                 fname, ver = fileRegistry[i]
#                 if fname == filename:
#                     found = True
#                     break
#             if not found:
#                 fileRegistry.append((filename, 0))
#             
#             # Track version number
#             self.versionNum = self.getVersionNumber(filename)
#             openHandles.append((self, filename, self.versionNum, True))
#     
#     
#     def getVersionNumber(self, filename):
#         for fname, versionNum in fileRegistry:
#             if fname == filename:
#                 return versionNum
#         return 0
#     
#     
#     def setVersionNumber(self, filename, versionNum):
#         for i in range(len(fileRegistry)):
#             fname, oldVersion = fileRegistry[i]
#             if fname == filename:
#                 fileRegistry[i] = (filename, versionNum)
#                 return
#         fileRegistry.append((filename, versionNum))
#     
#     
#     def createNewVersion(self, filename):
#         # Check if the original file is currently open
#         for handle, fname, ver, isOrig in openHandles:
#             if fname == filename and isOrig:
#                 raise FileInUseError("File is currently open: " + filename)
#         
#         # Get current version number and increment
#         currentVersion = self.getVersionNumber(filename)
#         newVersion = currentVersion + 1
#         
#         # Create versioned filename
#         versionedFilename = filename + '.v' + str(newVersion)
#         
#         # Copy content from original to new version
#         oldHandle = openfile(filename, False)
#         content = oldHandle.readat(None, 0)
#         oldHandle.close()
#         
#         # Rename original to versioned file
#         newHandle = openfile(versionedFilename, True)
#         newHandle.writeat(content, 0)
#         newHandle.close()
#         
#         # Update registry
#         self.setVersionNumber(filename, newVersion)
#         
#         # Open the original file fresh for writing
#         self.handle = openfile(filename, True)
#         self.filename = filename
#         self.baseName = filename
#         self.versionNum = newVersion
#         self.isOriginal = True
#         
#         openHandles.append((self, filename, newVersion, True))
#     
#     
#     def readat(self, numBytes, offset):
#         # Verify file is still open
#         found = False
#         for handle, fname, ver, isOrig in openHandles:
#             if handle == self:
#                 found = True
#                 break
#         
#         if not found:
#             raise FileClosedError("File is closed")
#         
#         return self.handle.readat(numBytes, offset)
#     
#     
#     def writeat(self, data, offset):
#         # Verify file is still open
#         found = False
#         for handle, fname, ver, isOrig in openHandles:
#             if handle == self:
#                 found = True
#                 break
#         
#         if not found:
#             raise FileClosedError("File is closed")
#         
#         # Disallow writing to versioned files
#         if not self.isOriginal:
#             raise FileInUseError("Cannot write to versioned file: " + self.filename)
#         
#         self.handle.writeat(data, offset)
#     
#     
#     def close(self):
#         self.handle.close()
#         
#         # Remove from tracking
#         for i in range(len(openHandles)):
#             handle, fname, ver, isOrig = openHandles[i]
#             if handle == self:
#                 openHandles.pop(i)
#                 break
# 
# 
# def LPopenfile(filename, create):
#     return LPFile(filename, create)
# 
# 
# def LPremovefile(filename):
#     raise RepyArgumentError("File deletion is not allowed")
# 
# 
# def secureListfiles():
#     allFiles = listfiles()
#     originalFiles = []
#     
#     for filename in allFiles:
#         # Skip versioned files (those containing '.v' followed by digits at the end)
#         if '.v' in filename:
#             parts = filename.rsplit('.v', 1)
#             if len(parts) == 2 and parts[1].isdigit():
#                 continue
#         originalFiles.append(filename)
#     
#     return originalFiles
# 
# 
# # The code below sets up type checking and variable hiding for you.
# # You should not change anything below this point.
# sec_file_def = {
#     "obj-type": LPFile,
#     "name": "LPFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": LPFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": LPFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": LPFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

# Test 1: Basic immutability
f = openfile("immutable", True)
f.writeat("v0", 0)
f.close()

# Create version
f = openfile("immutable", True)
f.writeat("v1", 0)
f.close()

# Try to open base and write (should fail - it's an old version)
try:
    fold = openfile("immutable", False)
    try:
        fold.writeat("hack", 0)
        log("ERROR: Should not be able to write to old version\n")
        exitall()
    except FileInUseError:
        # Expected
        pass
    fold.close()
except FileNotFoundError:
    pass

# Test 2: Edge case filename
f2 = openfile("normal", True)
f2.writeat("test", 0)
f2.close()

# Version it
f3 = openfile("normal", True)
content = f3.readat(None, 0)
if content != "test":
    log("ERROR: Version should copy content\n")
    exitall()
f3.close()

# Verify listfiles
files = listfiles()
if "normal" not in files:
    log("ERROR: Base file should be in listfiles\n")
    exitall()
if "normal.v1" in files:
    log("ERROR: Version should not be in listfiles\n")
    exitall()
