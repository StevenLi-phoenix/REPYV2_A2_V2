"""
==============================================================================
ATTACK CASE: lp2989_attackcase7.r2py
==============================================================================
Target NetID:        lp2989
Original Test:       test05_read_old_versions.r2py
Test File Path:      submit/general_tests/test05_read_old_versions.r2py

RUNNER INFORMATION:
  Runner ID:         runner-9097
  Task UUID:         f12775ff-46b2-45bc-8476-78d0a50c7be0
  Machine Type:      t3.medium
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:24:10.727405
  End Time:          2025-10-27T19:24:15.240650
  Runtime:           4.5132 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       35df2e37fccc14818fc2c7a87fb63f07
  Attack MD5:        9bdf70bf198eb3ed48e2c8e61ca597b0
  Combined MD5:      a6e2ec35e06a7e98d7b95bd3fadd16e2

FAILURE DETAILS:
  Reason:            ---
Uncaught exception!
---
Following is a full traceback, and a user traceback.
The user traceback 

STDOUT:
  ---
  Uncaught exception!
  ---
  Following is a full traceback, and a user traceback.
  The user traceback excludes non-user modules. The most recent call is displayed last.
  Full debugging traceback:
    "/app/repy.py", line 134, in execute_namespace_until_completion
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "/app/encasementlib.r2py", line 240, in <module>
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "/app/namespace.py", line 957, in __do_func_call
    "/app/namespace.py", line 1219, in wrapped_function
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "monitor.r2py", line 288, in <module>
    "/app/encasementlib.r2py", line 175, in _secure_dispatch_closure
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "/app/namespace.py", line 957, in __do_func_call
    "/app/namespace.py", line 1219, in wrapped_function
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "attack.r2py", line 11, in <module>
    "VMFile wrapper class", line 3, in writeat
    "wrapper.r2py", line 202, in _wrapped_func
    "monitor.r2py", line 181, in writeat
  User traceback:
    "/app/encasementlib.r2py", line 240, in <module>
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "monitor.r2py", line 288, in <module>
    "/app/encasementlib.r2py", line 175, in _secure_dispatch_closure
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "attack.r2py", line 11, in <module>
    "VMFile wrapper class", line 3, in writeat
    "wrapper.r2py", line 202, in _wrapped_func
    "monitor.r2py", line 181, in writeat
  Exception (with type 'exceptions.ValueError'): File is immutable - cannot modify after initial write
  ---

ORIGINAL TEST DESCRIPTION:
  Test 5: Can read from old versions
  Verifies that old versions remain readable

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: lp2989)
# ============================================================================
# """
# This security layer implements Versioned and Immutable file functionality with robust error handling
# 
# Note:
#     This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
#     Also you need to give it an application to run.
#     python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
#     
# Specification:
#     1. Files are immutable once created - no modifications allowed after creation
#     2. When creating a file that exists, create a new version (v1, v2, v3, etc.)
#     3. Versions are read-only and cannot be deleted
#     4. Original files can be deleted, but this creates a new version with the delete recorded
# """
# 
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"  
# OBJC = "objc"
# 
# # Global state management with thread safety
# mycontext['open_files'] = set()
# mycontext['file_locks'] = {}
# mycontext['file_metadata'] = {}  # Track write status
# mycontext['global_lock'] = createlock()
# 
# def get_file_lock(filename):
#     """Get or create a lock for a specific file"""
#     mycontext['global_lock'].acquire(True)
#     try:
#         if filename not in mycontext['file_locks']:
#             mycontext['file_locks'][filename] = createlock()
#         return mycontext['file_locks'][filename]
#     finally:
#         mycontext['global_lock'].release()
# 
# def validate_filename(filename):
#     """Validate filename according to strict rules"""
#     if not filename or not isinstance(filename, str):
#         raise RepyArgumentError("Filename must be a non-empty string")
#     
#     if len(filename) > 120:
#         raise RepyArgumentError("Filename exceeds maximum length of 120 characters")
#     
#     if filename in ['.', '..'] or filename.startswith('.'):
#         raise RepyArgumentError("Invalid filename: cannot start with '.' or be '.' or '..'")
#     
#     # Allow lowercase letters, numbers, dots, hyphens, underscores
#     allowed_chars = "abcdefghijklmnopqrstuvwxyz0123456789.-_"
#     for char in filename:
#         if char not in allowed_chars:
#             raise RepyArgumentError("Filename contains invalid character: '" + char + "'")
#     
#     return True
# 
# def get_next_version(base_filename):
#     """Find the next available version number for a file"""
#     existing_files = listfiles()
#     version = 1
#     
#     while True:
#         versioned_name = base_filename + ".v" + str(version)
#         if versioned_name not in existing_files:
#             return versioned_name, version
#         version += 1
#         
#         # Safety check to prevent infinite loops
#         if version > 10000:
#             raise ResourceExhaustedError("Too many versions of file")
# 
# def is_version_file(filename):
#     """Check if a filename is a version file (ends with .vN)"""
#     if '.v' not in filename:
#         return False
#     
#     parts = filename.rsplit('.v', 1)
#     if len(parts) == 2:
#         try:
#             int(parts[1])
#             return True
#         except ValueError:
#             return False
#     return False
# 
# class VMFile():
#     def __init__(self, filename, create):
#         mycontext['debug'] = False
#         
#         # Validate filename
#         validate_filename(filename)
#         
#         self.filename = filename
#         self.is_closed = False
#         self.has_written = False
#         self.file_lock = get_file_lock(filename)
#         
#         # Acquire lock for thread-safe initialization
#         self.file_lock.acquire(True)
#         try:
#             # Check if file is already open
#             if filename in mycontext['open_files']:
#                 raise FileInUseError("File '" + filename + "' is already open")
#             
#             if create:
#                 # Creating a new file or version
#                 if filename in listfiles():
#                     # File exists - create a versioned copy
#                     
#                     # First, read the existing file's content
#                     try:
#                         existing_file = openfile(filename, False)
#                         content = existing_file.readat(None, 0)
#                         existing_file.close()
#                     except FileInUseError:
#                         raise FileInUseError("Cannot create version: base file is in use")
#                     
#                     # Find next version number and create versioned file
#                     versioned_name, version_num = get_next_version(filename)
#                     self.filename = versioned_name
#                     self.VMfile = openfile(versioned_name, True)
#                     
#                     # Copy existing content to new version
#                     if content:
#                         self.VMfile.writeat(content, 0)
#                         self.has_written = True
#                 else:
#                     # File doesn't exist - create new file
#                     self.VMfile = openfile(filename, True)
#             else:
#                 # Opening existing file for reading
#                 if filename not in listfiles():
#                     raise FileNotFoundError("File '" + filename + "' does not exist")
#                 
#                 self.VMfile = openfile(filename, False)
#                 
#                 # Mark as already written if it's a version file or has metadata
#                 if is_version_file(filename) or filename in mycontext['file_metadata']:
#                     self.has_written = True
#             
#             # Track open file
#             mycontext['open_files'].add(self.filename)
#             
#         finally:
#             self.file_lock.release()
# 
#     def readat(self, num_bytes, offset):
#         """Read from file with validation"""
#         self.file_lock.acquire(True)
#         try:
#             if self.is_closed:
#                 raise FileClosedError("Cannot read from closed file")
#             
#             if offset < 0:
#                 raise RepyArgumentError("Offset cannot be negative")
#             
#             if num_bytes is not None and num_bytes < 0:
#                 raise RepyArgumentError("Number of bytes cannot be negative")
#             
#             return self.VMfile.readat(num_bytes, offset)
#         finally:
#             self.file_lock.release()
# 
#     def writeat(self, data, offset):
#         """Write to file - only allowed once during creation"""
#         self.file_lock.acquire(True)
#         try:
#             if self.is_closed:
#                 raise FileClosedError("Cannot write to closed file")
#             
#             if offset < 0:
#                 raise RepyArgumentError("Offset cannot be negative")
#             
#             if not isinstance(data, str):
#                 raise RepyArgumentError("Data must be a string")
#             
#             # Immutability enforcement: only allow writes during initial creation
#             if self.has_written:
#                 raise ValueError("File is immutable - cannot modify after initial write")
#             
#             # Version files should never be written to after creation
#             if is_version_file(self.filename):
#                 raise ValueError("Version files are immutable")
#             
#             self.VMfile.writeat(data, offset)
#             self.has_written = True
#             mycontext['file_metadata'][self.filename] = True
#             
#         finally:
#             self.file_lock.release()
# 
#     def close(self):
#         """Close file and update tracking"""
#         self.file_lock.acquire(True)
#         try:
#             if self.is_closed:
#                 raise FileClosedError("File is already closed")
#             
#             self.VMfile.close()
#             self.is_closed = True
#             
#             # Remove from open files set
#             mycontext['open_files'].discard(self.filename)
#             
#         finally:
#             self.file_lock.release()
# 
# 
# def LPopenfile(filename, create):
#     """Open file with validation"""
#     validate_filename(filename)
#     return VMFile(filename, create)
# 
# 
# def LPremovefile(filename):
#     """Remove file with restrictions on version files"""
#     validate_filename(filename)
#     
#     mycontext['global_lock'].acquire(True)
#     try:
#         # Check if file is open
#         if filename in mycontext['open_files']:
#             raise FileInUseError("Cannot remove open file: '" + filename + "'")
#         
#         # Prevent deletion of version files (they are immutable)
#         if is_version_file(filename):
#             raise ValueError("Cannot delete version files - they are immutable")
#         
#         # Check if file exists
#         if filename not in listfiles():
#             raise FileNotFoundError("File '" + filename + "' does not exist")
#         
#         # Remove the file
#         removefile(filename)
#         
#         # Clean up metadata
#         if filename in mycontext['file_metadata']:
#             del mycontext['file_metadata'][filename]
#         if filename in mycontext['file_locks']:
#             del mycontext['file_locks'][filename]
#             
#     finally:
#         mycontext['global_lock'].release()
# 
# 
# def LPlistfiles():
#     """List all files in the system"""
#     return listfiles()
# 
# 
# # The code below sets up type checking and variable hiding for you.
# # You should not change anything below this point.
# sec_file_def = {
#     "obj-type": VMFile,
#     "name": "VMFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#     TYPE: FUNC,
#     ARGS: None,
#     EXCP: Exception,
#     RETURN: list,
#     TARGET: LPlistfiles
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

f1 = openfile("testfile5", True)
f1.writeat("Original", 0)
f1.close()

f2 = openfile("testfile5", True)
f2.writeat("NewVersion", 0)
f2.close()

# Read from base version
f3 = openfile("testfile5", False)
content = f3.readat(None, 0)
if content != "Original":
    log("ERROR: Should be able to read old version\n")
    exitall()
f3.close()

# Read from v1
f4 = openfile("testfile5.v1", False)
content = f4.readat(None, 0)
if content != "NewVersion":
    log("ERROR: Should be able to read versioned file\n")
    exitall()
f4.close()

