"""
==============================================================================
ATTACK CASE: rsu2009_attackcase5.r2py
==============================================================================
Target NetID:        rsu2009
Original Test:       test20_immutability_enforcement.r2py
Test File Path:      submit/general_tests/test20_immutability_enforcement.r2py

RUNNER INFORMATION:
  Runner ID:         runner-3752
  Task UUID:         d739372d-3606-4bbd-9c73-390c912f10cd
  Machine Type:      Standard_F4s_v2
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:26:46.494502
  End Time:          2025-10-27T19:26:51.072606
  Runtime:           4.5781 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       57fe62a08db3ff1f8d6780d54f4d8046
  Attack MD5:        b2a8ad98a6911bcd1c0c5534521a675b
  Combined MD5:      f77d2d0b137d00f7e20bdc3f50ff0331

FAILURE DETAILS:
  Reason:            ERROR: Should not be able to write to old version


STDOUT:
  ERROR: Should not be able to write to old version

ORIGINAL TEST DESCRIPTION:
  Targets: sa9082, wjl9629, hl5031
  Vulnerability: Immutability not properly enforced across edge cases
  Attack: Test immutability with various file opening patterns and edge case names

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: rsu2009)
# ============================================================================
# """
# This security layer inadequately handles the Versioned and Immutable functionality
# 
# Note:
#     This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
#     Also you need to give it an application to run.
#     python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
#     
# """
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"  
# OBJC = "objc"
# 
# try: # create locks to prevent race conditions + if lock exists, use
#     if 'lock_file_versions' not in mycontext:
#         mycontext['lock_file_versions'] = createlock()
#     if 'lock_open_handles' not in mycontext:
#         mycontext['lock_open_handles'] = createlock()
# except: 
#     pass
# 
# lock_file_versions = mycontext.get('lock_file_versions', None)
# lock_open_handles = mycontext.get('lock_open_handles', None)
# 
# file_versions = {} #maps files og name to list of ver names
# open_handles = {} #maps files og name to set of open handlers --> prevents multiple writers
# 
# # helper functions
# 
# # checks if filename includes ver suffix
# def _is_explicit_version(fname):
#     parts = fname.rsplit('.v', 1)
#     return (len(parts) == 2 and parts[1].isdigit())
# 
# # returns base name of teh file (removes .vN suffix)
# def _orig_from_version(fname):
#     if _is_explicit_version(fname):
#         return fname.rsplit('.v', 1)[0]
#     return fname
# 
# # gens next seq version name for file
# def _next_version_name(orig, locked=False):
#     if not locked and lock_file_versions:
#         lock_file_versions.acquire(True)
#     try:
#         lst = file_versions.get(orig, None)
#         if not lst:
#             return orig
#         next_idx = len(lst)  # produces .v1 when lst == ['orig']
#         return orig + ".v" + str(next_idx)
#     finally:
#         if not locked and lock_file_versions:
#             lock_file_versions.release()
# 
# # adds new ver to global tracking dictionary W/ lock
# def _register_new_file(orig, versionname, locked = False):
#     if not locked and lock_file_versions:
#         lock_file_versions.acquire(True)
#     try:
#         lst = file_versions.get(orig, None)
#         if lst is None:
#             file_versions[orig] = [versionname]
#         else:
#             lst.append(versionname)
#     finally:
#         if not locked and lock_file_versions:
#             lock_file_versions.release()
# 
# # returns most recent ver name for file
# def _latest_version_name(orig, locked=False):
#     if not locked and lock_file_versions:
#         lock_file_versions.acquire(True)
#     try:
#         lst = file_versions.get(orig, None)
#         if lst and len(lst) > 0:
#             return lst[-1]
#         return None
#     finally:
#         if not locked and lock_file_versions:
#             lock_file_versions.release()
# 
# 
# # keeps track of which files open + removal when closed
# def _register_open_handle(orig, wrapper):
#     if lock_open_handles:
#         lock_open_handles.acquire(True)
#     try:
#         s = open_handles.get(orig, None)
#         if s is None:
#             open_handles[orig] = set ([wrapper])
#         else:
#             s.add(wrapper)
#     finally:
#         if lock_open_handles:
#             lock_open_handles.release()
# 
# # prevents writing to files that are in use
# def _unregister_open_handle(orig, wrapper):
#     if lock_open_handles:
#         lock_open_handles.acquire(True)
#     try:
#         s = open_handles.get(orig, None)
#         if not s:
#             return
#         if wrapper in s:
#             s.remove(wrapper)
#         if len(s) == 0:
#             try:
#                 del open_handles[orig]
#             except KeyError:
#                 pass
#     finally:
#         if lock_open_handles:
#             lock_open_handles.release()
# 
# # check whether latest ver of file is curr open (block concurrent writes)
# def _is_latest_open(orig):
#     if lock_open_handles:
#         lock_open_handles.acquire(True)
#     try:
#         latest = _latest_version_name(orig)
#         if not latest:
#             return False
#         s = open_handles.get(orig, None)
#         if not s:
#             return False
#         for w in s:
#             if getattr(w,"versionname", None) == latest and not getattr(w, "closed", False):
#                 return True
#         return False
#     finally:
#         if lock_open_handles:
#             lock_open_handles.release()
# 
# 
# # startup scan
# 
# # when layer starts scans file sys and builds initial map of which vers already exists
# # knows how many vers before new ops happen
# try:
#     f1 = listfiles()
#     for n in f1:
#         if _is_explicit_version(n):
#             orig = _orig_from_version(n)
#             lst = file_versions.get(orig, None)
#             if lst is None:
#                 file_versions[orig] = [n]
#             else:
#                 if n not in lst:
#                     lst.append(n)
#         else:
#             lst = file_versions.get(n, None)
#             if lst is None:
#                 file_versions[n] = [n]
#             else:
#                 if n not in lst:
#                     lst.append(n)
# except Exception:
#     pass
# 
# class VMFile():
#     def __init__(self, filename, create):
#     # If a file with the same 'filename' already exists, this creates a new version 'filename.v1'.
#     # (Incomplete: does not handle further versions like v2, v3, etc.)
#         
#         self.origname = _orig_from_version(filename)
#         self.closed = False
#         try:
#             self.filelock = createlock()
#         except Exception:
#             self.filelock = None
# 
#         # explicit vN and create = true --> not allowed so raise error
#         if _is_explicit_version(filename) and create:
#             raise RepyArgumentError("Cannot create explicit versioned files")
# 
#         # create new ver if needed
#         if create:
#             if _is_latest_open(self.origname):
#                 raise FileInUseError("File in Use")
#             if lock_file_versions:
#                 lock_file_versions.acquire(True)
#             try:
#                 latest = _latest_version_name(self.origname, locked = True)
#                 if latest is None:
#                     self.VMFile = openfile(self.origname, True)
#                     self.versionname = self.origname
#                     _register_new_file(self.origname, self.versionname, locked = True)
#                 else:
#                     prev_file = openfile(latest, False)
#                     try:
#                         content = prev_file.readat(None, 0)
#                     finally:
#                         prev_file.close()
#                     new_name = _next_version_name(self.origname, locked = True)
#                     newfile = openfile(new_name, True)
#                     try:
#                         if content is not None and len(content) > 0:
#                             newfile.writeat(content, 0)
#                     except Exception:
#                         try: 
#                             newfile.close()
#                         except Exception:
#                             pass
#                         raise
#                     self.VMFile = newfile
#                     self.versionname = new_name
#                     _register_new_file(self.origname, self.versionname, locked = True)
#             finally:
#                 if lock_file_versions:
#                     lock_file_versions.release()
#         else: # open existing ver
#             if _is_explicit_version(filename):
#                 self.versionname = filename
#                 self.VMFile = openfile(self.versionname, False)
#             else:
#                 latest = _latest_version_name(filename)
#                 if latest is None:
#                     raise FileNotFoundError(filename)
#                 self.versionname = latest
#                 self.VMFile = openfile(self.versionname, False)
# 
#         _register_open_handle(self.origname, self)
# 
#     def readat(self, num_bytes, offset):
#         return self.VMFile.readat(num_bytes, offset)
# 
#     def writeat(self, data, offset):
#         if self.filelock:
#             self.filelock.acquire(True)
#         try:
#             latest = _latest_version_name(self.origname)
#             if self.versionname != latest:
#                 raise FileInUseError("Cannot write to older version (immutable)")
#             return self.VMFile.writeat(data, offset)
#         finally:
#             if self.filelock:
#                 self.filelock.release()
# 
#     def close(self):
#         if self.filelock:
#             self.filelock.acquire(True)
#         try:
#             res = self.VMFile.close()
#             self.closed = True
#             _unregister_open_handle(self.origname, self)
#             return res
#         finally:
#             if self.filelock:
#                 self.filelock.release()
# 
# 
# def LPopenfile(filename, create):
#     return VMFile(filename, create)
# 
# def LPremovefile(filename):
#     raise RepyArgumentError("Removing files is forbidden")
# 
# def LPlistfiles():
#     files = []
#     if lock_file_versions:
#         lock_file_versions.acquire(True)
#     try:
#         for orig in file_versions.keys():
#             if _latest_version_name(orig, locked = True):
#                 files.append(orig)
#     finally:
#         if lock_file_versions:
#             lock_file_versions.release()
#     return files
# 
# # The code below sets up type checking and variable hiding for you.
# # You should not change anything below this point.
# sec_file_def = {
#     "obj-type": VMFile,
#     "name": "VMFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#     TYPE: FUNC,
#     ARGS: None,
#     EXCP: Exception,
#     RETURN: list,
#     TARGET: LPlistfiles
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

# Test 1: Basic immutability
f = openfile("immutable", True)
f.writeat("v0", 0)
f.close()

# Create version
f = openfile("immutable", True)
f.writeat("v1", 0)
f.close()

# Try to open base and write (should fail - it's an old version)
try:
    fold = openfile("immutable", False)
    try:
        fold.writeat("hack", 0)
        log("ERROR: Should not be able to write to old version\n")
        exitall()
    except FileInUseError:
        # Expected
        pass
    fold.close()
except FileNotFoundError:
    pass

# Test 2: Edge case filename
f2 = openfile("normal", True)
f2.writeat("test", 0)
f2.close()

# Version it
f3 = openfile("normal", True)
content = f3.readat(None, 0)
if content != "test":
    log("ERROR: Version should copy content\n")
    exitall()
f3.close()

# Verify listfiles
files = listfiles()
if "normal" not in files:
    log("ERROR: Base file should be in listfiles\n")
    exitall()
if "normal.v1" in files:
    log("ERROR: Version should not be in listfiles\n")
    exitall()
