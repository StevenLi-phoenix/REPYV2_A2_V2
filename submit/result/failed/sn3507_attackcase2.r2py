"""
==============================================================================
ATTACK CASE: sn3507_attackcase2.r2py
==============================================================================
Target NetID:        sn3507
Original Test:       test04_immutable_old_versions.r2py
Test File Path:      submit/general_tests/test04_immutable_old_versions.r2py

RUNNER INFORMATION:
  Runner ID:         runner-3747
  Task UUID:         3be9580b-5674-478d-b2b8-0db6be5549d1
  Machine Type:      c5.xlarge
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:27:30.922407
  End Time:          2025-10-27T19:27:34.925757
  Runtime:           4.0034 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       a689e6aca26a9f993342c27c59f9dca1
  Attack MD5:        9b7d716d61c8c7daa6399db16d01b176
  Combined MD5:      8654c056d5463c970803093a0a197ac9

FAILURE DETAILS:
  Reason:            ERROR: Should not allow writing to old version


STDOUT:
  ERROR: Should not allow writing to old version

ORIGINAL TEST DESCRIPTION:
  Test 4: Cannot write to old versions
  Verifies immutability is enforced after closing files

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: sn3507)
# ============================================================================
# # Type and context definition constants
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"
# OBJC = "objc"
# 
# fileRegistry = []  # List of (filename, latest_version_number) tuples
# openHandles = []   # List of (file_object, filename, version_num, is_original) tuples
# 
# 
# class LPFile():
#     
#     def __init__(self, filename, create):
#         mycontext['debug'] = False
#         
#         # Parse filename to check if it's a versioned file request
#         baseName, versionNum = self.parseFilename(filename)
#         
#         # Validate versioned file creation attempts
#         if versionNum is not None and create:
#             raise RepyArgumentError("Cannot create explicit version files")
#         
#         # Handle file opening/creation logic
#         if versionNum is not None:
#             # Opening a specific version
#             self.openSpecificVersion(filename, baseName, versionNum, create)
#         else:
#             # Opening the original file
#             self.openOrCreateOriginal(filename, create)
#     
#     
#     def parseFilename(self, filename):
#         if '.v' in filename:
#             parts = filename.rsplit('.v', 1)
#             if len(parts) == 2 and parts[1].isdigit():
#                 return parts[0], int(parts[1])
#         return filename, None
#     
#     
#     def openSpecificVersion(self, fullFilename, baseName, versionNum, create):
#         # Check if the versioned file exists
#         fileList = listfiles()
#         fileExists = False
#         for existingFile in fileList:
#             if existingFile == fullFilename:
#                 fileExists = True
#                 break
#         
#         if not fileExists:
#             raise FileNotFoundError("File not found: " + fullFilename)
#         
#         # Open the versioned file
#         self.handle = openfile(fullFilename, False)
#         self.filename = fullFilename
#         self.baseName = baseName
#         self.versionNum = versionNum
#         self.isOriginal = False
#         
#         # Track this open handle
#         openHandles.append((self, fullFilename, versionNum, False))
#     
#     
#     def openOrCreateOriginal(self, filename, create):
#         fileList = listfiles()
#         fileExists = False
#         for existingFile in fileList:
#             if existingFile == filename:
#                 fileExists = True
#                 break
#         
#         if create and fileExists:
#             # Create a new version
#             self.createNewVersion(filename)
#         elif not create and not fileExists:
#             # Trying to open non-existent file without create flag
#             raise FileNotFoundError("File not found: " + filename)
#         else:
#             # Normal open or create
#             self.handle = openfile(filename, create)
#             self.filename = filename
#             self.baseName = filename
#             self.isOriginal = True
#             
#             # Initialize version tracking for new files
#             found = False
#             for i in range(len(fileRegistry)):
#                 fname, ver = fileRegistry[i]
#                 if fname == filename:
#                     found = True
#                     break
#             if not found:
#                 fileRegistry.append((filename, 0))
#             
#             # Track version number
#             self.versionNum = self.getVersionNumber(filename)
#             openHandles.append((self, filename, self.versionNum, True))
#     
#     
#     def getVersionNumber(self, filename):
#         for fname, versionNum in fileRegistry:
#             if fname == filename:
#                 return versionNum
#         return 0
#     
#     
#     def setVersionNumber(self, filename, versionNum):
#         for i in range(len(fileRegistry)):
#             fname, oldVersion = fileRegistry[i]
#             if fname == filename:
#                 fileRegistry[i] = (filename, versionNum)
#                 return
#         fileRegistry.append((filename, versionNum))
#     
#     
#     def createNewVersion(self, filename):
#         # Check if the original file is currently open
#         for handle, fname, ver, isOrig in openHandles:
#             if fname == filename and isOrig:
#                 raise FileInUseError("File is currently open: " + filename)
#         
#         # Get current version number and increment
#         currentVersion = self.getVersionNumber(filename)
#         newVersion = currentVersion + 1
#         
#         # Create versioned filename
#         versionedFilename = filename + '.v' + str(newVersion)
#         
#         # Copy content from original to new version
#         oldHandle = openfile(filename, False)
#         content = oldHandle.readat(None, 0)
#         oldHandle.close()
#         
#         # Rename original to versioned file
#         newHandle = openfile(versionedFilename, True)
#         newHandle.writeat(content, 0)
#         newHandle.close()
#         
#         # Update registry
#         self.setVersionNumber(filename, newVersion)
#         
#         # Open the original file fresh for writing
#         self.handle = openfile(filename, True)
#         self.filename = filename
#         self.baseName = filename
#         self.versionNum = newVersion
#         self.isOriginal = True
#         
#         openHandles.append((self, filename, newVersion, True))
#     
#     
#     def readat(self, numBytes, offset):
#         # Verify file is still open
#         found = False
#         for handle, fname, ver, isOrig in openHandles:
#             if handle == self:
#                 found = True
#                 break
#         
#         if not found:
#             raise FileClosedError("File is closed")
#         
#         return self.handle.readat(numBytes, offset)
#     
#     
#     def writeat(self, data, offset):
#         # Verify file is still open
#         found = False
#         for handle, fname, ver, isOrig in openHandles:
#             if handle == self:
#                 found = True
#                 break
#         
#         if not found:
#             raise FileClosedError("File is closed")
#         
#         # Disallow writing to versioned files
#         if not self.isOriginal:
#             raise FileInUseError("Cannot write to versioned file: " + self.filename)
#         
#         self.handle.writeat(data, offset)
#     
#     
#     def close(self):
#         self.handle.close()
#         
#         # Remove from tracking
#         for i in range(len(openHandles)):
#             handle, fname, ver, isOrig = openHandles[i]
#             if handle == self:
#                 openHandles.pop(i)
#                 break
# 
# 
# def LPopenfile(filename, create):
#     return LPFile(filename, create)
# 
# 
# def LPremovefile(filename):
#     raise RepyArgumentError("File deletion is not allowed")
# 
# 
# def secureListfiles():
#     allFiles = listfiles()
#     originalFiles = []
#     
#     for filename in allFiles:
#         # Skip versioned files (those containing '.v' followed by digits at the end)
#         if '.v' in filename:
#             parts = filename.rsplit('.v', 1)
#             if len(parts) == 2 and parts[1].isdigit():
#                 continue
#         originalFiles.append(filename)
#     
#     return originalFiles
# 
# 
# # The code below sets up type checking and variable hiding for you.
# # You should not change anything below this point.
# sec_file_def = {
#     "obj-type": LPFile,
#     "name": "LPFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": LPFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": LPFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": LPFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

f1 = openfile("testfile4", True)
f1.writeat("Original", 0)
f1.close()

f2 = openfile("testfile4", True)
f2.writeat("NewVersion", 0)
f2.close()

# Try to open and write to the base version (now immutable)
f3 = openfile("testfile4", False)
try:
    f3.writeat("Hack", 0)
    log("ERROR: Should not allow writing to old version\n")
    exitall()
except FileInUseError:
    pass
f3.close()

