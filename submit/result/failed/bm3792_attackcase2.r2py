"""
==============================================================================
ATTACK CASE: bm3792_attackcase2.r2py
==============================================================================
Target NetID:        bm3792
Original Test:       test11_version_readonly.r2py
Test File Path:      submit/general_tests/test11_version_readonly.r2py

RUNNER INFORMATION:
  Runner ID:         runner-9547
  Task UUID:         4f5974de-6540-4853-b677-27f20e4dbe94
  Machine Type:      n2-standard-4
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:20:38.477473
  End Time:          2025-10-27T19:20:43.177870
  Runtime:           4.7004 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       f88542dddd058af2a1fb37991dd3a1a6
  Attack MD5:        be269b8b0b711bacf397eda82dfc2332
  Combined MD5:      d976266ef0078385f986e9a76a428fcd

FAILURE DETAILS:
  Reason:            ERROR: Should not allow writing to version file


STDOUT:
  ERROR: Should not allow writing to version file

ORIGINAL TEST DESCRIPTION:
  Test 11: Version files are read-only by default
  Verifies that version files cannot be written to

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: bm3792)
# ============================================================================
# """
# This security layer handles Versioned and Immutable file functionality
# 
# Note:
#     This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
#     Also you need to give it an application to run.
#     python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
# """
# 
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"  
# OBJC = "objc"
# 
# # Global state tracking
# open_files = {}
# file_versions = {}
# closed_versions = set()
# 
# 
# def get_base_filename(filename):
#     """Extract base filename from versioned filename."""
#     if '.v' in filename:
#         parts = filename.split('.v')
#         if len(parts) == 2:
#             try:
#                 int(parts[1])
#                 return parts[0]
#             except ValueError:
#                 pass
#     return filename
# 
# 
# def get_version_number(filename):
#     """Get version number from filename, returns 0 if base file."""
#     if '.v' in filename:
#         parts = filename.split('.v')
#         if len(parts) == 2:
#             try:
#                 return int(parts[1])
#             except ValueError:
#                 pass
#     return 0
# 
# 
# def find_highest_version(base_filename):
#     """Find the highest version number that exists for a base filename."""
#     all_files = listfiles()
#     highest = -1
#     
#     if base_filename in all_files:
#         highest = 0
#     
#     version_num = 1
#     while True:
#         versioned_name = base_filename + ".v" + str(version_num)
#         if versioned_name in all_files:
#             highest = version_num
#             version_num += 1
#         else:
#             break
#     
#     return highest
# 
# 
# class VMFile():
#     def __init__(self, filename, create):
#         self.filename = filename
#         self.is_version_file = '.v' in filename
#         base_name = get_base_filename(filename)
#         
#         # Check if trying to manually create a version file
#         if create and self.is_version_file:
#             raise RepyArgumentError("Cannot create explicit version files")
#         
#         if create:
#             # Creating a new file or version
#             # First, scan the filesystem to find the actual highest version
#             latest_version = find_highest_version(base_name)
#             
#             # Update our tracking to match reality
#             if latest_version >= 0:
#                 file_versions[base_name] = latest_version
#             
#             if latest_version >= 0:
#                 # File exists, need to create a new version
#                 if latest_version == 0:
#                     latest_file = base_name
#                 else:
#                     latest_file = base_name + ".v" + str(latest_version)
#                 
#                 # Check if latest version is currently open
#                 if latest_file in open_files:
#                     raise FileInUseError("Cannot create new version while latest version is open")
#                 
#                 # Create next version
#                 new_version_num = latest_version + 1
#                 new_filename = base_name + ".v" + str(new_version_num)
#                 
#                 # Copy contents from latest version
#                 content = ""
#                 try:
#                     prev_file = openfile(latest_file, False)
#                     content = prev_file.readat(None, 0)
#                     prev_file.close()
#                 except FileNotFoundError:
#                     content = ""
#                 except Exception:
#                     content = ""
#                 
#                 # Create new version file
#                 self.VMfile = openfile(new_filename, True)
#                 
#                 # Write the copied content if there is any
#                 if len(content) > 0:
#                     self.VMfile.writeat(content, 0)
#                 
#                 self.actual_filename = new_filename
#                 file_versions[base_name] = new_version_num
#                 
#             else:
#                 # New file, create base file
#                 self.VMfile = openfile(base_name, True)
#                 self.actual_filename = base_name
#                 file_versions[base_name] = 0
#             
#             # Track as open
#             open_files[self.actual_filename] = self
#             self.is_closed = False
#             
#         else:
#             # Opening existing file for reading
#             self.VMfile = openfile(filename, False)
#             self.actual_filename = filename
#             self.is_closed = False
#             
#             # Check if it's already open
#             if filename in open_files:
#                 self.VMfile.close()
#                 raise FileInUseError("File is already open")
#             
#             open_files[filename] = self
# 
#     def readat(self, num_bytes, offset):
#         if self.is_closed:
#             raise FileClosedError("File is closed")
#         return self.VMfile.readat(num_bytes, offset)
# 
#     def writeat(self, data, offset):
#         if self.is_closed:
#             raise FileClosedError("File is closed")
#         
#         # Check if this is an old version by checking if it's not the latest
#         base_name = get_base_filename(self.actual_filename)
#         
#         # First check the filesystem for the actual latest version
#         actual_latest = find_highest_version(base_name)
#         
#         # Update our tracking
#         if actual_latest >= 0:
#             if base_name not in file_versions or file_versions[base_name] < actual_latest:
#                 file_versions[base_name] = actual_latest
#         
#         if base_name in file_versions:
#             latest_version = file_versions[base_name]
#             current_version = get_version_number(self.actual_filename)
#             
#             # If this is not the latest version, it's read-only
#             if latest_version > current_version:
#                 raise FileInUseError("Cannot write to old version")
#         
#         return self.VMfile.writeat(data, offset)
# 
#     def close(self):
#         if self.is_closed:
#             return
#         
#         result = self.VMfile.close()
#         self.is_closed = True
#         
#         # Remove from open files
#         if self.actual_filename in open_files:
#             del open_files[self.actual_filename]
#         
#         # Mark as closed version (immutable)
#         closed_versions.add(self.actual_filename)
#         
#         return result
# 
# 
# def LPopenfile(filename, create):
#     return VMFile(filename, create)
# 
# 
# def LPremovefile(filename):
#     # File deletion is not allowed
#     raise RepyArgumentError("File deletion is not allowed")
# 
# 
# def LPlistfiles():
#     # Return only base filenames, hide versions
#     all_files = listfiles()
#     base_files = set()
#     
#     for f in all_files:
#         base_name = get_base_filename(f)
#         base_files.add(base_name)
#     
#     return list(base_files)
# 
# 
# # The code below sets up type checking and variable hiding for you.
# # You should not change anything below this point.
# sec_file_def = {
#     "obj-type": VMFile,
#     "name": "VMFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#     TYPE: FUNC,
#     ARGS: None,
#     EXCP: Exception,
#     RETURN: list,
#     TARGET: LPlistfiles
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

f1 = openfile("testfile11", True)
f1.writeat("V1", 0)
f1.close()

f2 = openfile("testfile11", True)
f2.writeat("V2", 0)
f2.close()

# Try to write to v1
f3 = openfile("testfile11.v1", False)
try:
    f3.writeat("Hack", 0)
    log("ERROR: Should not allow writing to version file\n")
    exitall()
except FileInUseError:
    pass
f3.close()

