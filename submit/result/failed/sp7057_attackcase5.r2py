"""
==============================================================================
ATTACK CASE: sp7057_attackcase5.r2py
==============================================================================
Target NetID:        sp7057
Original Test:       test05_read_old_versions.r2py
Test File Path:      submit/general_tests/test05_read_old_versions.r2py

RUNNER INFORMATION:
  Runner ID:         runner-9376
  Task UUID:         df6a375a-b25f-404e-bca4-a181d2b6d613
  Machine Type:      e2-medium
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:27:36.950824
  End Time:          2025-10-27T19:27:43.148211
  Runtime:           6.1974 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       cb68470638cb9e512ca41471d194807a
  Attack MD5:        9bdf70bf198eb3ed48e2c8e61ca597b0
  Combined MD5:      80870958915664e5a06c90d1d810d126

FAILURE DETAILS:
  Reason:            ---
Uncaught exception!
---
Following is a full traceback, and a user traceback.
The user traceback 

STDOUT:
  ---
  Uncaught exception!
  ---
  Following is a full traceback, and a user traceback.
  The user traceback excludes non-user modules. The most recent call is displayed last.
  Full debugging traceback:
    "/app/repy.py", line 134, in execute_namespace_until_completion
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "/app/encasementlib.r2py", line 240, in <module>
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "/app/namespace.py", line 957, in __do_func_call
    "/app/namespace.py", line 1219, in wrapped_function
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "monitor.r2py", line 250, in <module>
    "/app/encasementlib.r2py", line 175, in _secure_dispatch_closure
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "/app/namespace.py", line 957, in __do_func_call
    "/app/namespace.py", line 1219, in wrapped_function
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "attack.r2py", line 15, in <module>
    "wrapper.r2py", line 255, in _wrapped_objc
    "wrapper.r2py", line 202, in _wrapped_func
    "monitor.r2py", line 203, in LPopenfile
    "monitor.r2py", line 167, in __init__
  User traceback:
    "/app/encasementlib.r2py", line 240, in <module>
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "monitor.r2py", line 250, in <module>
    "/app/encasementlib.r2py", line 175, in _secure_dispatch_closure
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "attack.r2py", line 15, in <module>
    "wrapper.r2py", line 255, in _wrapped_objc
    "wrapper.r2py", line 202, in _wrapped_func
    "monitor.r2py", line 203, in LPopenfile
    "monitor.r2py", line 167, in __init__
  Exception (with class 'exception_hierarchy.FileNotFoundError'): 
  ---

ORIGINAL TEST DESCRIPTION:
  Test 5: Can read from old versions
  Verifies that old versions remain readable

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: sp7057)
# ============================================================================
# """
# This security layer inadequately handles the Versioned and Immutable functionality
# 
# Note:
#     This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
#     Also you need to give it an application to run.
#     python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
#     
# """
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"  
# OBJC = "objc"
# VALID_FILENAME_CHARS = set("abcdefghijklmnopqrstuvwxyz0123456789-_.")
# 
# # create a dictionary that keeps track of all files created, open, closed, etc
# # each dict entry should include the original filename, latest version num and sets of all open and prev versions
# fileLibrary = {}
# 
# #saving the original function for later, to be able to access all files (even versioned if i want to)
# list_all_files = listfiles
# og_open = openfile
# og_rem = removefile
# 
# def unique_files(allFiles):
# # will create a set of unique filenames (not showing the versions) for our listfiles modification
#     toShow = set()
#     all_ogNames = []
#     for name in allFiles:
#         ogName, _ = version_check(name)
#         if ogName not in toShow:
#             toShow.add(ogName)
#             all_ogNames.append(ogName)
#     return all_ogNames
# 
# def extract_version(filename):
# # returns the original filename (str), the version num (int) and the version string filename extension '' or '.vN'
#     originalName, num = version_check(filename)
#     if num is None:
#         return originalName, None, ""
#     else:
#         return originalName, num, ".v" + str(num)
# 
# 
# def filename_check(filename):
#     # check that filename is valid, return true if it is
#     if not filename or filename in ('.', '..'):
#         return False
#     if len(filename) > 120:
#         return False
#     if filename[0] == '.':
#         return False
#     for char in filename:
#         if char not in VALID_FILENAME_CHARS:
#             return False
#     return True
# 
# def version_check(filename):
#     #return true if it is versioned and the version number
#     # Find the last occurrence of ".v"
#     versionIndex = filename.rfind('.v')
#     if versionIndex == -1:
#         return filename, None
#     versionNum = filename[versionIndex+2:]
#     #check that .v isn't followed by a 0
#     if versionNum[0] == '0':
#         return filename, None
#     # Require at least one digit and all digits
#     digits = True
#     i=0
#     while i < len(versionNum):
#         c = versionNum[i]
#         if not ('0'<=c and c<='9'):
#             digits = False
#             break
#         i+=1
#     if digits:
#         try:
#             #check if ".v" is followed by integers 
#             num = int(versionNum)
#         except:
#             #if not treat it as a normal filename (not versioned)
#             return filename, None
#         #if there are versions separate the filename from the version part and 
#         # return the old file name (oldName) and version number
#         oldName = filename[:versionIndex]
#         return oldName, num
# 
#     return filename, None
# 
# 
# 
# class VMFile():
#     def __init__(self, filename, create):
# 
#         #if the filename is invalid raise Error
#         if not filename_check(filename):
#             raise RepyArgumentError("Invalid Filename")
#     
#         #If a file with the same 'filename' already exists, this creates a new version 'filename.v(num)'.
#         #file exists but we need to break it down into two cases 1) we are creating the first version, 2) it is already versioned (raises error)
#         #to update the file name accordingly
#         name, num, versionExtension = extract_version(filename)
#         
#         #if the file is not in our library dict, add it 
#         if name not in fileLibrary:
#             fileLibrary[name] = {"version":0, "open":set(), "allVersions":set()}
# 
#         currentFile = fileLibrary[name]
# 
#         def updated_filename(num):
#             if num == 0:
#                 return name  
#             else:
#                 return name + ".v{}".format(num)
# 
# 
#         if create:
#             exists = filename in list_all_files()
#             if exists:  
#                 #File exists
#                 if num == None:
#                     prev_full = updated_filename(currentFile["version"]) 
#                     if prev_full in currentFile["open"]:                         
#                         raise FileInUseError("Latest version is open")
#                     # create new version
#                     new_name = updated_filename(currentFile["version"]+1) 
#                     prev_file = og_open(prev_full, False)
#                     content = prev_file.readat(None, 0)
#                     #CANNOT create new version while old version is open
#                     prev_file.close()
#                     self.VMfile = og_open(new_name, True)
#                     self.VMfile.writeat(content, 0)
# 
#                     # update the file library
#                     currentFile["version"]+=1
#                     currentFile["allVersions"].add(new_name) 
#                     currentFile["open"].add(new_name)
#                     #update names
#                     self.oldName = name
#                     self.fullName = new_name
#                 else: 
#                     #create = True cannot be used in a versioned file
#                     raise RepyArgumentError("Cannot create explicit version files")
#             else:
#                 # File doesn't exist â†’ create filename
#                 self.VMfile = og_open(filename, True)
#                 currentFile["allVersions"].add(name)
#                 currentFile["open"].add(name)
#                 self.oldName = name
#                 self.fullName = name
#         else:
#             #if an openfile call with create=False, open the file only if that version exists; otherwise, raise FileNotFoundError
#             exists = filename in list_all_files()
#             if exists: 
#                 # make sure to open the most recent one
#                 most_recent = updated_filename(num)
#                 if most_recent in currentFile["allVersions"]:
#                     self.VMfile = og_open(most_recent, False)
#                     currentFile["open"].add(most_recent)
#                     self.oldName = name
#                     self.fullName = most_recent
#                     return
#                 raise FileNotFoundError 
#             else:
#                 raise FileNotFoundError
#            
#     def readat(self, num_bytes, offset):
#         return self.VMfile.readat(num_bytes, offset)
# 
#     def writeat(self, data, offset):
#         currentFile = fileLibrary.get(self.oldName)
#         # check if file is in the library
#         if currentFile == None:
#             raise FileInUseError("Invalid filename")
#         # check that we are trying to write to the most recent version 
#         most_recent = currentFile["version"]
#         if most_recent == 0:
#             most_recent_file = self.oldName
#         else:
#             most_recent_file = self.oldName + ".v{}".format(most_recent)
#         if most_recent_file != self.fullName:
#             raise FileInUseError
#         #make sure that the file is open, once it is closed you cannot write to it again
#         if not (self.fullName in currentFile["open"]):
#             raise FileInUseError
#         return self.VMfile.writeat(data, offset)
# 
#     def close(self):
#         try: 
#             closed = self.VMfile.close()
#         finally:
#             currentFile = fileLibrary.get(self.oldName)
#             # make sure to remove the file name from the list of open handles in the file library
#             if currentFile:
#                 currentFile["open"].discard(self.fullName)
#         return closed
# 
# def LPopenfile(filename, create):
#     return VMFile(filename, create)
# 
# def LPremovefile(filename):
# # make sure deletion of files is not allowed
#     raise RepyArgumentError
# 
# def LPlistfiles():
#     allFiles = list_all_files()
#     # only shows original filenames and not how many versions exist
#     return unique_files(allFiles)
# 
# 
# # The code below sets up type checking and variable hiding for you.
# # You should not change anything below this point.
# sec_file_def = {
#     "obj-type": VMFile,
#     "name": "VMFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#     TYPE: FUNC,
#     ARGS: None,
#     EXCP: Exception,
#     RETURN: list,
#     TARGET: LPlistfiles
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

f1 = openfile("testfile5", True)
f1.writeat("Original", 0)
f1.close()

f2 = openfile("testfile5", True)
f2.writeat("NewVersion", 0)
f2.close()

# Read from base version
f3 = openfile("testfile5", False)
content = f3.readat(None, 0)
if content != "Original":
    log("ERROR: Should be able to read old version\n")
    exitall()
f3.close()

# Read from v1
f4 = openfile("testfile5.v1", False)
content = f4.readat(None, 0)
if content != "NewVersion":
    log("ERROR: Should be able to read versioned file\n")
    exitall()
f4.close()

