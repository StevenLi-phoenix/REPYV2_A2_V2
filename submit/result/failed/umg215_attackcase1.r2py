"""
==============================================================================
ATTACK CASE: umg215_attackcase1.r2py
==============================================================================
Target NetID:        umg215
Original Test:       test11_version_readonly.r2py
Test File Path:      submit/general_tests/test11_version_readonly.r2py

RUNNER INFORMATION:
  Runner ID:         runner-7358
  Task UUID:         6132f304-6ab9-4347-8c8e-3ecb5cf93127
  Machine Type:      t3.large
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:28:16.356118
  End Time:          2025-10-27T19:28:21.810293
  Runtime:           5.4542 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       e40276afcf37a32908f31335904e4405
  Attack MD5:        be269b8b0b711bacf397eda82dfc2332
  Combined MD5:      ea2f0ab43f73324aefeffc933f4139be

FAILURE DETAILS:
  Reason:            ERROR: Should not allow writing to version file


STDOUT:
  ERROR: Should not allow writing to version file

ORIGINAL TEST DESCRIPTION:
  Test 11: Version files are read-only by default
  Verifies that version files cannot be written to

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: umg215)
# ============================================================================
# TYPE   = "type"
# ARGS   = "args"
# RETURN = "return"
# EXCP   = "exceptions"
# TARGET = "target"
# FUNC   = "func"
# OBJC   = "objc"
# 
# OPEN_FILES = {}
# FILE_STATE = {}
# 
# # save the real runtime functions before we export our wrappers
# real_openfile = openfile
# real_listfiles = listfiles
# real_removefile = removefile
# 
# 
# 
# # helper functions
# 
# 
# def split_version(fname):
#   """Return (base, ver). If no '.vN' suffix, ver == 0."""
#   idx = fname.rfind(".v")
#   if idx != -1 and idx + 2 < len(fname):
#     suf = fname[idx+2:]
#     if suf.isdigit():
#       base = fname[:idx]
#       return base, int(suf)
#   return fname, 0
# 
# def is_versioned_name(fname):
#   _, v = split_version(fname)
#   return v > 0
# 
# def highest_version(base):
#   files = real_listfiles()
#   maxv = 0
#   i = 0
#   while i < len(files):
#     f = files[i]
#     b, v = split_version(f)
#     if b == base and v > maxv:
#       maxv = v
#     i += 1
#   return maxv
# 
# def latest_name(base):
#   hv = highest_version(base)
#   if hv > 0:
#     return base + ".v" + str(hv)
#   files = real_listfiles()
#   i = 0
#   while i < len(files):
#     if files[i] == base:
#       return base
#     i += 1
#   return None
# 
# def copy_from(src, dst):
#   h = real_openfile(src, False)
#   try:
#     data = h.readat(None, 0)
#   finally:
#     h.close()
# 
#   d = real_openfile(dst, True)
#   try:
#     if data:
#       d.writeat(data, 0)
#   finally:
#     d.close()
# 
# 
# 
# # VMFile: wrapper object
# 
# 
# class VMFile:
#   def __init__(self, name, create):
#     # disallow manual creation of explicit version filenames like "foo.v1"
#     if create and is_versioned_name(name):
#       raise RepyArgumentError()
# 
#     base, ver = split_version(name)
#     files = real_listfiles()
# 
#     if create:
#       # first creation ever for this base
#       if base not in files and highest_version(base) == 0:
#         self.fname = base
#         self.handle = real_openfile(base, True)
#       else:
#         # base already exists --> create a new version
#         latest = latest_name(base)
# 
#         # probe: try to open latest non-creating. If it's open, raise FileInUseError
#         try:
#           probe = real_openfile(latest, False)
#         except FileInUseError:
#           raise FileInUseError()
#         else:
#           try:
#             content = probe.readat(None, 0)
#           finally:
#             probe.close()
# 
#         new_ver = highest_version(base) + 1
#         new_name = base + ".v" + str(new_ver)
# 
#         # create the new version and initialize with the copied content
#         newf = real_openfile(new_name, True)
#         try:
#           if content:
#             newf.writeat(content, 0)
#         finally:
#           # keep this handle open for the caller
#           self.handle = newf
# 
#         self.fname = new_name
#     else:
#       # create=False -> must already exist
#       files = real_listfiles()
#       if name not in files:
#         raise FileNotFoundError()
#       self.fname = name
#       self.handle = real_openfile(name, False)
# 
#     # bookkeeping
#     FILE_STATE[self.fname] = "open"
#     b, v = split_version(self.fname)
#     if highest_version(b) == v:
#       OPEN_FILES[b] = self
# 
#   def readat(self, num_bytes, offset):
#     return self.handle.readat(num_bytes, offset)
# 
#   def writeat(self, data, offset):
#     base, ver = split_version(self.fname)
#     # only allow writes to the latest version (ver == highest)
#     if ver != highest_version(base):
#       # raise FileInUseError
#       raise FileInUseError()
#     return self.handle.writeat(data, offset)
# 
#   def close(self):
#     FILE_STATE[self.fname] = "closed"
#     try:
#       self.handle.close()
#     finally:
#       # clear OPEN_FILES mapping if this object was the recorded "open" instance
#       b, v = split_version(self.fname)
#       if OPEN_FILES.get(b) is self:
#         try:
#           del OPEN_FILES[b]
#         except KeyError:
#           pass
#     return True
# 
# 
# 
# # functions exported to the child
# 
# 
# def LPopenfile(name, create):
#   return VMFile(name, create)
# 
# def LPremovefile(name):
#   # removal not allowed
#   raise RepyArgumentError()
# 
# def LPlistfiles():
#   raw = real_listfiles()
#   bases = []
#   seen = set()
#   i = 0
#   while i < len(raw):
#     b, _ = split_version(raw[i])
#     if b not in seen:
#       seen.add(b)
#       bases.append(b)
#     i += 1
#   return bases
# 
# 
# 
# # encasementlib
# 
# sec_file_def = {
#   "obj-type": VMFile,
#   "name": "VMFile",
#   "writeat": {"type": FUNC,
#               "args": (str, (int, long)),
#               "exceptions": Exception,
#               "return": (int, type(None)),
#               "target": VMFile.writeat},
#   "readat":  {"type": FUNC,
#               "args": ((int, long, type(None)), (int, long)),
#               "exceptions": Exception,
#               "return": str,
#               "target": VMFile.readat},
#   "close":   {"type": FUNC,
#               "args": None,
#               "exceptions": Exception,
#               "return": (bool, type(None)),
#               "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#   TYPE: OBJC,
#   ARGS: (str, bool),
#   EXCP: Exception,
#   RETURN: sec_file_def,
#   TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#   TYPE: FUNC,
#   ARGS: (str,),
#   EXCP: Exception,
#   RETURN: type(None),
#   TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#   TYPE: FUNC,
#   ARGS: None,
#   EXCP: Exception,
#   RETURN: list,
#   TARGET: LPlistfiles
# }
# 
# secure_dispatch_module()
# 
# ============================================================================

f1 = openfile("testfile11", True)
f1.writeat("V1", 0)
f1.close()

f2 = openfile("testfile11", True)
f2.writeat("V2", 0)
f2.close()

# Try to write to v1
f3 = openfile("testfile11.v1", False)
try:
    f3.writeat("Hack", 0)
    log("ERROR: Should not allow writing to version file\n")
    exitall()
except FileInUseError:
    pass
f3.close()

