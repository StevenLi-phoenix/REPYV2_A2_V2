"""
==============================================================================
ATTACK CASE: az2924_attackcase15.r2py
==============================================================================
Target NetID:        az2924
Original Test:       test14_offset_writes.r2py
Test File Path:      submit/general_tests/test14_offset_writes.r2py

RUNNER INFORMATION:
  Runner ID:         runner-1327
  Task UUID:         63997963-1e4b-4e87-8027-c0f592cbb6a5
  Machine Type:      m5.large
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:20:12.534979
  End Time:          2025-10-27T19:20:17.903642
  Runtime:           5.3687 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       100698f3024b7e34e3b686117beedfa5
  Attack MD5:        7bfa3cf4af9d4fc392c6c7a0cf6750ba
  Combined MD5:      039a628b56f9e3453e3a30695f56952e

FAILURE DETAILS:
  Reason:            ---
Uncaught exception!
---
Following is a full traceback, and a user traceback.
The user traceback 

STDOUT:
  ---
  Uncaught exception!
  ---
  Following is a full traceback, and a user traceback.
  The user traceback excludes non-user modules. The most recent call is displayed last.
  Full debugging traceback:
    "/app/repy.py", line 134, in execute_namespace_until_completion
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "/app/encasementlib.r2py", line 240, in <module>
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "/app/namespace.py", line 957, in __do_func_call
    "/app/namespace.py", line 1219, in wrapped_function
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "monitor.r2py", line 183, in <module>
    "/app/encasementlib.r2py", line 175, in _secure_dispatch_closure
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "/app/namespace.py", line 957, in __do_func_call
    "/app/namespace.py", line 1219, in wrapped_function
    "/app/virtual_namespace.py", line 116, in evaluate
    "/app/safe.py", line 610, in safe_run
    "attack.r2py", line 7, in <module>
    "VMFile wrapper class", line 3, in writeat
    "wrapper.r2py", line 202, in _wrapped_func
    "monitor.r2py", line 124, in writeat
    "/app/safe.py", line 515, in exceptionraiser
  User traceback:
    "/app/encasementlib.r2py", line 240, in <module>
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "monitor.r2py", line 183, in <module>
    "/app/encasementlib.r2py", line 175, in _secure_dispatch_closure
    "/app/encasementlib.r2py", line 225, in secure_dispatch
    "attack.r2py", line 7, in <module>
    "VMFile wrapper class", line 3, in writeat
    "wrapper.r2py", line 202, in _wrapped_func
    "monitor.r2py", line 124, in writeat
  Unsafe call: ("Unsafe call 'getattr' with args '(<.VMFile object at 0x7b5fa4d4a410>, 'latestFile', True)', kwargs '{}'",)
  ---

ORIGINAL TEST DESCRIPTION:
  Test 14: Large offset writes
  Verifies that data written at large offsets is preserved across versions

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: az2924)
# ============================================================================
# """
# This security layer inadequately handles the Versioned and Immutable functionality
# 
# Note:
#     This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
#     Also you need to give it an application to run.
#     python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
#     
# """
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"
# OBJC = "objc"
# 
# openFiles = set()
# 
# class VMFile(object):
#     def __init__(self, filename, create):
#         if ".v" in filename:
#             # Raise error if file doesn't exist
#             if filename not in listfiles():
#                 raise FileNotFoundError("File version was not found.")
# 
#             # Raise error if try to create another version
#             if create:
#                 raise RepyArgumentError("Cannot create another version of file")
# 
#             # Prevent opening if it's opened elsewhere
#             if filename in openFiles:
#                 raise FileInUseError("File is already opened.")
# 
#             # See if it's latest version of the file
#             baseName = filename.split(".v")[0]
#             relatedFiles = []
#             fileList = listfiles()
#             for file in fileList:
#                 if file == baseName or file.startswith(baseName + ".v"):
#                     relatedFiles.append(file)
# 
#             relatedFiles.sort()
#             latestName = relatedFiles[-1]
# 
#             # If so, then rewrite
#             self.fileName = filename
#             self.latestFile = (filename == latestName)
#             self.VMfile = openfile(filename, False)
#             openFiles.add(filename)
#             return
# 
#         # If file's already opened, then don't open it again.
#         coreName = filename
#         if coreName in openFiles:
#             raise FileInUseError("File is already opened.")
# 
#         # Store all file versions in a list
#         relatedFiles = []
#         fileList = listfiles()
#         for file in fileList:
#             if file == coreName or file.startswith(coreName + ".v"):
#                 relatedFiles.append(file)
# 
#         # Sort files and set latestName by the latest file
#         relatedFiles.sort()
#         containsFile = len(relatedFiles) > 0
#         if containsFile:
#             latestName = relatedFiles[-1]
#         else:
#             latestName = coreName
# 
#         if create:
#             # Create file and filename if new
#             if not containsFile:
#                 self.fileName = coreName
#                 self.latestFile = True
#                 self.VMfile = openfile(coreName, True)
#                 openFiles.add(coreName)
#                 return
# 
#             # If not new file, then don't create new.
#             if latestName in openFiles:
#                 raise FileInUseError("Cannot create new version.")
# 
#             # Open latest file to copy into new file
#             latest = openfile(latestName, False)
#             try:
#                 info = latest.readat(None, 0)
#             finally:
#                 latest.close()
# 
#             # Create new version using old version's info
#             newVersion = coreName + ".v" + str(len(relatedFiles))
#             if newVersion in openFiles:
#                 raise FileInUseError("New version is already open.")
# 
#             self.fileName = newVersion
#             self.latestFile = True
#             self.VMfile = openfile(newVersion, True)
#             if info is not None:
#                 self.VMfile.writeat(info, 0)
#             openFiles.add(newVersion)
#             return
# 
#         # Error if still no prior files
#         if not containsFile:
#             raise FileNotFoundError("File is not found.")
# 
#         if latestName in openFiles:
#             raise FileInUseError("File is already opened.")
# 
#         self.fileName = latestName
#         self.latestFile = True
#         self.VMfile = openfile(latestName, False)
#         openFiles.add(latestName)
# 
#     # Read file
#     def readat(self, num_bytes, offset):
#         return self.VMfile.readat(num_bytes, offset)
# 
#     # Write to a file
#     def writeat(self, data, offset):
#         if not getattr(self, "latestFile", True):
#             raise FileInUseError("Cannot write to file.")
#         return self.VMfile.writeat(data, offset)
# 
#     # Remove open files from list when closing
#     def close(self):
#         fileName = self.fileName
#         if fileName in openFiles:
#             openFiles.remove(fileName)
#         return self.VMfile.close()
# 
# # Opens a file
# def LPopenfile(filename, create):
#     return VMFile(filename, create)
# 
# # Error for deleting a file
# def LPremovefile(filename):
#     raise RepyArgumentError("File deletion is not allowed.")
# 
# # Adds files to the set
# def LPlistfiles():
#     filesSet = set()
#     for file in listfiles():
#         filesSet.add(file.split(".v")[0])
#     return list(filesSet)
# 
# sec_file_def = {
#     "obj-type": VMFile,
#     "name": "VMFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#     TYPE: FUNC,
#     ARGS: None,
#     EXCP: Exception,
#     RETURN: [str],
#     TARGET: LPlistfiles
# }
# 
# # Execute the user code
# secure_dispatch_module()
# ============================================================================

f1 = openfile("testfile14", True)
f1.writeat("Start", 0)
# Fill the gap with spaces to avoid SeekPastEndOfFileError
f1.writeat(" " * 95, 5)
f1.writeat("End", 100)
f1.close()

f2 = openfile("testfile14", True)
content = f2.readat(None, 0)
if len(content) < 103:
    log("ERROR: Content with large offset should be preserved\n")
    exitall()
if content[100:103] != "End":
    log("ERROR: Data at offset should be preserved\n")
    exitall()
f2.close()

