"""
==============================================================================
ATTACK CASE: hh2727_attackcase2.r2py
==============================================================================
Target NetID:        hh2727
Original Test:       test05_read_old_versions.r2py
Test File Path:      submit/general_tests/test05_read_old_versions.r2py

RUNNER INFORMATION:
  Runner ID:         runner-3890
  Task UUID:         c66e97fa-83a4-421d-8293-2625e5aaf541
  Machine Type:      n2-standard-8
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:21:49.708400
  End Time:          2025-10-27T19:21:55.503721
  Runtime:           5.7953 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       c4a7892f5a4e580985ba9a538910fee2
  Attack MD5:        9bdf70bf198eb3ed48e2c8e61ca597b0
  Combined MD5:      3e9b422bceb84a7078f1e6dd012831c9

FAILURE DETAILS:
  Reason:            ERROR: Should be able to read old version


STDOUT:
  ERROR: Should be able to read old version

ORIGINAL TEST DESCRIPTION:
  Test 5: Can read from old versions
  Verifies that old versions remain readable

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: hh2727)
# ============================================================================
# """
# By Bob Huang / hh2727 / N10590703
# reference_monitor_hh2727.r2py
# 
# run: python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
#     
# Policy: files immutable after close.
# 
# 
# 
# """
# 
# REAL_openfile   = openfile
# REAL_removefile = removefile
# REAL_listfiles  = listfiles
# 
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"  
# OBJC = "objc"
# 
# 
# # keep file sample in memory
# _state = {}
# 
# 
# def ensure_entry(base_name):
#   if base_name not in _state:
#     _state[base_name] = {
#       'latest': 0,
#       'open': set(),
#       'writing': False
#     }
#   return _state[base_name]
# 
# def is_version(name):
#   if ".v" not in name:
#     return (False, None, None)
#   parts = name.split(".v")
#   if len(parts) != 2 or not parts[1].isdigit():
#     return (False, None, None)
#   base = parts[0]
#   if base == "":
#     return (False, None, None)
#   ver = int(parts[1])
#   if ver < 1:
#     return (False, None, None)
#   return (True, base, ver)
# 
# def base_exists(base):
#   for f in REAL_listfiles():
#     ok, b, v = is_version(f)
#     if f == base or (ok and b == base):
#       return True
#   return False
# 
# def read_all(f): return f.readat(None, 0)
# def write_all(f, d): return f.writeat(d, 0)
# 
# def copy_file(src, dst):
#   s = REAL_openfile(src, False)
#   data = read_all(s)
#   s.close()
#   write_all(dst, data)
# 
# # file object
# class VMFile(object):
#   def __init__(self, name, create):
#     if not name or name.startswith("."):
#       raise RepyArgumentError("bad name")
#     if len(name) > 120:
#       raise RepyArgumentError("too long")
# 
#     self.name = name
#     self.base = name
#     self.writable = False
#     self.version = None
# 
#     isv, base, ver = is_version(name)
#     if isv:
#       if create:
#         raise RepyArgumentError("can't create .vN directly")
#       self.base = base
#       meta = ensure_entry(base)
#       if name in meta["open"]:
#         raise FileInUseError("already open")
#       self.fh = REAL_openfile(name, False)
#       meta["open"].add(name)
#       return
# 
#     base = name
#     meta = ensure_entry(base)
# 
#     if create:
#       if meta["writing"]:
#         raise FileInUseError("another create open")
#       if base_exists(base):
#         meta["latest"] += 1
#         newv = meta["latest"]
#         self.fh = REAL_openfile(base, True)
#         prev = base + ".v" + str(newv - 1)
#         copy_file(prev, self.fh)
#         self.version = newv
#       else:
#         meta["latest"] = 1
#         self.fh = REAL_openfile(base, True)
#         self.version = 1
#       if base in meta["open"]:
#         raise FileInUseError("already open")
#       meta["open"].add(base)
#       meta["writing"] = True
#       self.writable = True
#       self.base = base
#       return
# 
#     if base in meta["open"]:
#       raise FileInUseError("already open")
#     if not base_exists(base):
#       raise FileNotFoundError("no such file")
#     self.fh = REAL_openfile(base, False)
#     meta["open"].add(base)
# 
#   def readat(self, n, off): return self.fh.readat(n, off)
# 
#   def writeat(self, d, off):
#     if not self.writable:
#       raise FileInUseError("immutable")
#     return self.fh.writeat(d, off)
# 
#   def close(self):
#     res = self.fh.close()
#     base = self.base
#     meta = ensure_entry(base)
#     if self.name in meta["open"]:
#       meta["open"].remove(self.name)
#     if self.writable and self.version:
#       snap = base + ".v" + str(self.version)
#       vfh = REAL_openfile(snap, True)
#       bfh = REAL_openfile(base, False)
#       write_all(vfh, read_all(bfh))
#       bfh.close()
#       vfh.close()
#       meta["writing"] = False
#     self.writable = False
#     self.version = None
#     return res
# 
# # wrappers
# def LPopenfile(name, create): return VMFile(name, create)
# def LPremovefile(name): raise RepyArgumentError("remove not allowed")
# 
# def LPlistfiles():
#   real = REAL_listfiles()
#   seen = set()
#   out = []
#   for f in real:
#     isv, base, ver = is_version(f)
#     if isv:
#       if base not in seen:
#         seen.add(base)
#         out.append(base)
#     else:
#       if f not in out:
#         out.append(f)
#   return out
# 
# # encasementlib defs
# sec_file_def = {
#   "obj-type": VMFile,
#   "name": "VMFile",
#   "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
#   "readat":  {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
#   "close":   {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#   "type": OBJC,
#   "args": (str, bool),
#   "exceptions": Exception,
#   "return": sec_file_def,
#   "target": LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#   "type": "func",
#   "args": (str,),
#   "exceptions": Exception,
#   "return": type(None),
#   "target": LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#   "type": "func",
#   "args": None,
#   "exceptions": Exception,
#   "return": list,
#   "target": LPlistfiles
# }
# 
# secure_dispatch_module()
# 
# 
# 
# 
# ============================================================================

f1 = openfile("testfile5", True)
f1.writeat("Original", 0)
f1.close()

f2 = openfile("testfile5", True)
f2.writeat("NewVersion", 0)
f2.close()

# Read from base version
f3 = openfile("testfile5", False)
content = f3.readat(None, 0)
if content != "Original":
    log("ERROR: Should be able to read old version\n")
    exitall()
f3.close()

# Read from v1
f4 = openfile("testfile5.v1", False)
content = f4.readat(None, 0)
if content != "NewVersion":
    log("ERROR: Should be able to read versioned file\n")
    exitall()
f4.close()

