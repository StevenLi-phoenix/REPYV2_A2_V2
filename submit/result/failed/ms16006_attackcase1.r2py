"""
==============================================================================
ATTACK CASE: ms16006_attackcase1.r2py
==============================================================================
Target NetID:        ms16006
Original Test:       test05_read_old_versions.r2py
Test File Path:      submit/general_tests/test05_read_old_versions.r2py

RUNNER INFORMATION:
  Runner ID:         runner-9300
  Task UUID:         0d6e98d7-fd42-4e9b-a624-c7a961b553f5
  Machine Type:      Standard_F4s_v2
  Execution Server:  http://100.88.83.27:8000

EXECUTION INFORMATION:
  Status:            FAILED
  Start Time:        2025-10-27T19:24:36.754988
  End Time:          2025-10-27T19:24:39.535721
  Runtime:           2.7807 seconds
  Exit Code:         143

FILE HASHES:
  Monitor MD5:       d4522059ca3a18c4b4a3ad0d61e2daa4
  Attack MD5:        9bdf70bf198eb3ed48e2c8e61ca597b0
  Combined MD5:      ffe91f68d0eb20b92ec25b99d8938304

FAILURE DETAILS:
  Reason:            ERROR: Should be able to read versioned file


STDOUT:
  ERROR: Should be able to read versioned file

ORIGINAL TEST DESCRIPTION:
  Test 5: Can read from old versions
  Verifies that old versions remain readable

==============================================================================
"""

# ============================================================================
# REFERENCE MONITOR CODE (Target: ms16006)
# ============================================================================
# # reference_monitor_ms16006.r2py
# 
# TYPE = "type"
# ARGS = "args"
# RETURN = "return"
# EXCP = "exceptions"
# TARGET = "target"
# FUNC = "func"
# OBJC = "objc"
# 
# 
# def _all_files_list():
#     """just a Wrapper to call underlying listfiles() so we can iterate safely."""
#     return listfiles()
# 
# 
# def _get_all_versions(filename):
#     """Return list of versioned filenames for just the base filename."""
#     files = _all_files_list()
#     prefix = filename + ".v"
#     versions = []
#     i = 0
#     while i < len(files):
#         f = files[i]
#         # only accept proper prefix matches
#         if f[:len(prefix)] == prefix:
#             versions.append(f)
#         i += 1
#     return versions
# 
# 
# def _get_latest_version_number(filename):
#     """Return latest version number (int) or 0 if none exist."""
#     versions = _get_all_versions(filename)
#     if not versions:
#         return 0
#     nums = []
#     i = 0
#     while i < len(versions):
#         f = versions[i]
#         parts = f.split(".v")
#         # expect at least two parts: base and number
#         if len(parts) >= 2:
#             # last part should be numeric
#             try:
#                 n = int(parts[-1])
#                 nums.append(n)
#             except:
#                 # skip non-numeric suffixes
#                 pass
#         i += 1
#     if not nums:
#         return 0
#     # find max myself (reducing communication outside)
#     m = nums[0]
#     j = 1
#     while j < len(nums):
#         if nums[j] > m:
#             m = nums[j]
#         j += 1
#     return m
# 
# 
# def _get_latest_filename(filename):
#     """Return latest versioned filename, or the base name if none exist."""
#     latest_num = _get_latest_version_number(filename)
#     if latest_num == 0:
#         return filename
#     else:
#         return filename + ".v" + str(latest_num) # again just returning the name as a string
# 
# 
# class VMFile:
#         def __init__(self, filename, create):
#             # Disallow explicit creation of versioned filenames.
#             if filename.find(".v") != -1 and create:
#                 raise RepyArgumentError("Cannot create explicit version files") 
# 
#             self.filename = filename
#             self.closed = False
#             self.is_latest = False
#             self.VMfile = None
# 
#             # Initialize locals
#             exists_base = False
#             has_versions = False
#             found = False
# 
#             # Helper: recompute existence
#             def _recompute_exists(base):
#                 files_list = _all_files_list()
#                 ex_base = False
#                 ii = 0
#                 while ii < len(files_list):
#                     if files_list[ii] == base:
#                         ex_base = True
#                     ii += 1
#                 vslist = _get_all_versions(base)
#                 has_vs = len(vslist) > 0
#                 return (ex_base, has_vs)
# 
#             # initial scan
#             files_now = _all_files_list()
#             k = 0
#             while k < len(files_now):
#                 if files_now[k] == filename:
#                     exists_base = True
#                 k += 1
#             vs = _get_all_versions(filename)
#             if len(vs) > 0:
#                 has_versions = True
# 
#             # CREATION PATH
#             if create:
#                 # If nothing exists, create base safely with retries (thread safe try)
#                 if (not exists_base) and (not has_versions):
#                     for attempt in range(5):
#                         try:
#                             self.VMfile = openfile(filename, True)
#                             self.is_latest = True
#                             return
#                         except Exception as e:
#                             if "already open" in str(e) or "does not exist" in str(e):
#                                 sleep(0.05)
#                                 continue
#                             else:
#                                 raise
#                     raise FileInUseError("Concurrent open attempts for '{}' failed".format(filename))
# 
#                 # Ensure vmfile_locks exists
#                 if "vmfile_locks" not in mycontext:
#                     mycontext["vmfile_locks"] = {}
# 
#                 if filename not in mycontext["vmfile_locks"]:
#                     mycontext["vmfile_locks"][filename] = createlock()
# 
#                 file_lock = mycontext["vmfile_locks"][filename]
# 
#                 # Acquire lock for serialized version creation
#                 file_lock.acquire(True)
#                 try:
#                     exists_base2, has_versions2 = _recompute_exists(filename)
# 
#                     # Retry safe creation if no versions exist yet
#                     if (not exists_base2) and (not has_versions2):
#                         for attempt in range(5):
#                             try:
#                                 self.VMfile = openfile(filename, True)
#                                 self.is_latest = True
#                                 return
#                             except Exception as e:
#                                 if "already open" in str(e) or "does not exist" in str(e):
#                                     sleep(0.05)
#                                     continue
#                                 else:
#                                     raise
#                         raise FileInUseError("Concurrent open attempts for '{}' failed".format(filename))
# 
#                     # Loop until latest version becomes available
#                     while True:
#                         latest_name = _get_latest_filename(filename)
#                         try:
#                             probe = openfile(latest_name, False)
#                             try:
#                                 probe.close()
#                             except:
#                                 pass
#                             break  # latest is valid and closed
#                         except FileInUseError:
#                             file_lock.release()
#                             sleep(0.05)
#                             file_lock.acquire(True)
#                             continue
#                         except FileNotFoundError:
#                             exists_base2, has_versions2 = _recompute_exists(filename)
#                             if (not exists_base2) and (not has_versions2):
#                                 self.VMfile = openfile(filename, True)
#                                 self.is_latest = True
#                                 return
#                             continue
# 
#                     # Compute next version
#                     latest_ver_num = _get_latest_version_number(filename)
#                     new_ver_num = latest_ver_num + 1
#                     new_name = filename + ".v" + str(new_ver_num)
# 
#                     # Copy contents from latest (if exists)
#                     contents = ""
#                     try:
#                         src = openfile(latest_name, False)
#                         try:
#                             contents = src.readat(None, 0)
#                         finally:
#                             src.close()
#                     except FileNotFoundError:
#                         contents = ""
# 
#                     # Create new version and write data
#                     for attempt in range(5):
#                         try:
#                             self.VMfile = openfile(new_name, True)
#                             self.VMfile.writeat(contents, 0)
#                             self.is_latest = True
#                             return
#                         except Exception as e:
#                             if "already open" in str(e):
#                                 sleep(0.05)
#                                 continue
#                             else:
#                                 raise
#                     raise FileInUseError("Concurrent version creation for '{}' failed".format(filename))
#                 finally:
#                     try:
#                         file_lock.release()
#                     except:
#                         pass
#             else:
#                 found = False
#                 files_now2 = _all_files_list()
#                 idx = 0
#                 while idx < len(files_now2):
#                     if files_now2[idx] == filename:
#                         found = True
#                     idx += 1
# 
#                 if not found:
#                     vs2 = _get_all_versions(filename)
#                     v_idx = 0
#                     while v_idx < len(vs2):
#                         if vs2[v_idx] == filename:
#                             found = True
#                         v_idx += 1
# 
#                 if not found:
#                     raise FileNotFoundError("File does not exist")
# 
#                 # Open existing file (may raise FileInUseError)
#                 self.VMfile = openfile(filename, False)
# 
#                 # Determine if latest
#                 base_name = filename
#                 parts = filename.split(".v")
#                 if len(parts) >= 2:
#                     base_name = parts[0]
#                 latest_for_base = _get_latest_filename(base_name)
#                 if filename == latest_for_base:
#                     self.is_latest = True
#                 else:
#                     self.is_latest = False
# 
# 
# 
#         def readat(self, num_bytes, offset):
#             return self.VMfile.readat(num_bytes, offset)
# 
#         def writeat(self, data, offset):
#             # Only allow writes on the latest open version
#             if not self.is_latest:
#                 raise FileInUseError("Cannot write to older version")
# 
#             try:
#                 # Determine current file size to get append position
#                 # read and find length
#                 current_data = ""
#                 try:
#                     current_data = self.VMfile.readat(None, 0)
#                 except Exception:
#                     # If file just created or unreadable, assume empty
#                     current_data = ""
#                 append_offset = len(current_data)
# 
#                 # Force append behavior regardless of offset argument
#                 return self.VMfile.writeat(data, append_offset)
# 
#             except FileClosedError:
#                 # already closed 
#                 raise FileInUseError("File handle is closed / not writable")
# 
# 
# 
#         def close(self):
#             # Mark closed and forward the close
#             self.closed = True
#             return self.VMfile.close()
# 
# 
# # --- Secure Layer Exports ---
# 
# def LPopenfile(filename, create):
#     return VMFile(filename, create)
# 
# 
# def LPremovefile(filename):
#     # Deletion not allowed
#     raise RepyArgumentError("File deletion is not allowed")
# 
# 
# def LPlistfiles():
#     files = listfiles() 
#     base_files = []
#     i = 0
#     while i < len(files):
#         f = files[i]
#         # skip explicit version names like "foo.v1"
#         if f.find(".v") == -1:
#             base_files.append(f)
#         i += 1
# 
#     # return
#     j = 0
#     while j < len(base_files):
#         if not isinstance(base_files[j], str):
#             base_files[j] = str(base_files[j])
#         j += 1
# 
#     return base_files
# 
# 
# 
# # Encasement/Type def 
# 
# sec_file_def = {
#     "obj-type": VMFile,
#     "name": "VMFile",
#     "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception,
#                 "return": (int, type(None)), "target": VMFile.writeat},
#     "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception,
#                "return": str, "target": VMFile.readat},
#     "close": {"type": "func", "args": None, "exceptions": Exception,
#               "return": (bool, type(None)), "target": VMFile.close}
# }
# 
# CHILD_CONTEXT_DEF["openfile"] = {
#     TYPE: OBJC,
#     ARGS: (str, bool),
#     EXCP: Exception,
#     RETURN: sec_file_def,
#     TARGET: LPopenfile
# }
# 
# CHILD_CONTEXT_DEF["removefile"] = {
#     TYPE: FUNC,
#     ARGS: (str,),
#     EXCP: Exception,
#     RETURN: type(None),
#     TARGET: LPremovefile
# }
# 
# CHILD_CONTEXT_DEF["listfiles"] = {
#     TYPE: FUNC,
#     ARGS: None,
#     EXCP: Exception,
#     RETURN: list,
#     TARGET: LPlistfiles
# }
# 
# secure_dispatch_module()
# 
# ============================================================================

f1 = openfile("testfile5", True)
f1.writeat("Original", 0)
f1.close()

f2 = openfile("testfile5", True)
f2.writeat("NewVersion", 0)
f2.close()

# Read from base version
f3 = openfile("testfile5", False)
content = f3.readat(None, 0)
if content != "Original":
    log("ERROR: Should be able to read old version\n")
    exitall()
f3.close()

# Read from v1
f4 = openfile("testfile5.v1", False)
content = f4.readat(None, 0)
if content != "NewVersion":
    log("ERROR: Should be able to read versioned file\n")
    exitall()
f4.close()

