"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 
    
"""
TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

open_files = set()

class catch_return_bug:
    def readat(self, num_bytes, offset):
        return ""
    def writeat(self, data, offset):
        return None
    def close(self):
        return True


class VMFile():
    def __init__(self, filename, create):
    # If a file with the same 'filename' already exists, this creates a new version 'filename.v1'.
    # (Incomplete: does not handle further versions like v2, v3, etc.)

        self.VMfile = catch_return_bug()
        self.name = filename
        self.can_edit = False
        self.closed = True
        self._valid = False

        if create and ".v" in filename:
            #can't directly create versions
            parts = filename.rsplit(".v", 1)
            if len(parts) == 2 and parts[1].isdigit():
                #return 
                raise RepyArgumentError("Cannot create explicit version files")

        if create:
            if filename in listfiles():
                base = filename
                version = 0

                #split name into "filename" + ".v" + "everything else". can isolate version if everything else is a number
                if ".v" in filename:
                    parts = filename.rsplit(".v", 1)
                    if len(parts) == 2 and parts[1].isdigit():
                        base = parts[0]
                        version = int(parts[1])

                #need to copy from the latest version not the base version
                latest_ver = -1
                if base in listfiles():
                    latest_ver = max(latest_ver, 0)
                prefix = base + ".v"
                for fname in listfiles():
                    if fname.startswith(prefix):
                        suf = fname[len(prefix):]
                        if suf.isdigit():
                            v = int(suf)
                            if v > latest_ver:
                                latest_ver = v

                if latest_ver == 0:
                    latest_name = base
                else:
                    latest_name = base + ".v" + str(latest_ver)


                # after found latest version:
                if latest_name in open_files:
                    #return 
                    raise FileInUseError("Cannot create new version while latest version is open")

                prev_file = openfile(latest_name, False)
                content = prev_file.readat(None, 0)
                prev_file.close()

                #next new version
                version = latest_ver
                while True:
                    version += 1
                    new_name = base + ".v" + str(version)
                    if new_name not in listfiles():
                        break
                

                #finally create file
                self.VMfile = openfile(new_name, True)
                self.VMfile.writeat(content, 0)

                self.name = new_name
                self.can_edit = True
                self.closed = False
                open_files.add(self.name)

            else:
                self.VMfile = openfile(filename, True)
                self.name = filename
                self.can_edit = True
                self.closed = False
                open_files.add(self.name)
        else:
            # Open existing file normally
            files = listfiles()

            if filename not in files:
                #return
                raise FileNotFoundError("Filename not found")
            
            if filename in open_files:
                #return
                raise FileInUseError("File already open")

            self.VMfile = openfile(filename, False)
            self.name = filename
            self.can_edit = False
            self.closed = False
            open_files.add(self.name)

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        if self.closed:
            #return None
            raise FileInUseError("Cannot write to closed version")
        
        my_base = self.name
        my_ver = 0
        #similar logic to identifyingn version number as above
        if ".v" in self.name:
            parts = self.name.rsplit(".v", 1)
            if len(parts) == 2 and parts[1].isdigit():
                my_base = parts[0]
                my_ver = int(parts[1])

        files = listfiles()

        latest_ver = -1
        if my_base in files:
            latest_ver = max(latest_ver, 0)
        
        prefix = my_base + ".v"
        for file_name in files:
            if file_name.startswith(prefix):
                suf = file_name[len(prefix):]
                if suf.isdigit():
                    v = int(suf)
                    if v > latest_ver:
                        latest_ver = v

        if my_ver < latest_ver:
            #return None
            raise FileInUseError("Cannot write to older version")
        
        if not self.can_edit:
            #return None
            raise FileInUseError("Only creator can edit")

        return self.VMfile.writeat(data, offset)

    def close(self):
        self.closed = True
        if self.name in open_files:
            open_files.remove(self.name)
        return self.VMfile.close()


def LPopenfile(filename, create):
    #if create is 0, then will raise file not found error if filename not found
    return VMFile(filename, create)

def LPremovefile(filename):

    #return None
    raise RepyArgumentError("removefile is disabled")


def LPlistfiles():
    all_files = listfiles()
    bases = []
    for file in all_files:
        #same as above, split name to see if it is a version file or not
        parts = file.rsplit(".v", 1)
        if len(parts) == 2 and parts[1].isdigit():
            base = file.rsplit(".v", 1)[0]
        else:
            base = file

        if base not in bases:
            bases.append(base)
    return bases


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()