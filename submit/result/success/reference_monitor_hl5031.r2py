"""
This security layer inadequately handles the Versioned and Immutable functionality

Note:
    This security layer uses encasementlib.r2py, restrictions.default, repy.py and Python
    Also you need to give it an application to run.
    python repy.py restrictions.default encasementlib.r2py [security_layer].r2py [attack_program].r2py 

"""

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"  
OBJC = "objc"

# Globals to track versions and open state
# versions: base_filename
versions = {}
# open_handles: version_filename
open_handles = {}
# closed_versions: set of version filenames that have been closed
closed_versions = set()

def is_explicit_version(name):
    # Explicit version names look like base.vN where N is a valid positive integer
    parts = name.rsplit(".v", 1)
    if len(parts) != 2:
        return False
    suffix = parts[1]
    return suffix.isdigit() and suffix[0] != "0"

def parse_versioned(name):
    parts = name.rsplit(".v", 1)
    if len(parts) != 2:
        return (None, None)
    base, suffix = parts
    if suffix.isdigit() and suffix[0] != "0":
        return (base, int(suffix))
    return (None, None)

def latest_version_name(base):
    lst = versions.get(base)
    if not lst:
        return None
    return lst[-1]

def next_version_name(base):
    # If only base exists, the next version number is 1 (basename.v1)
    return base + ".v" + str(len(versions[base]))

class VMFile():
    def __init__(self, version_name, underlying_file_obj, base, is_versioned_explicit):
        """
        version_name: actual filename being operated on
        underlying_file_obj: the underlying Repy file object returned by openfile()
        base: the base filename (without .vN)
        is_versioned_explicit: True if user opened an explicit version like 'foo.v1', else False
        """
        self.version_name = version_name
        self.fileobj = underlying_file_obj
        self.base = base
        self.explicit_version_open = is_versioned_explicit
        self.closed = False

    def readat(self, num_bytes, offset):
        # All versions readable. Delegate directly
        return self.fileobj.readat(num_bytes, offset)

    def writeat(self, data, offset):
        latest = latest_version_name(self.base)
        if self.version_name != latest:
            # Writing older versions permanently disallowed
            raise FileInUseError("Writing to older versions is disallowed")
        if self.version_name in closed_versions or self.closed:
            # Already closed, immutable
            raise FileInUseError("Cannot write to a closed (immutable) file version")
        # Delegate to underlying write
        return self.fileobj.writeat(data, offset)

    def close(self):
        # Close underlying file object and mark this version immutable
        # If underlying close raises, propagate
        try:
            res = self.fileobj.close()
        finally:
            # Even if underlying close raises, still mark as closed to keep immutability guarantee
            closed_versions.add(self.version_name)
            # Remove from open_handles mapping
            if self.version_name in open_handles:
                try:
                    del open_handles[self.version_name]
                except KeyError:
                    pass
            self.closed = True
        return res

def LPopenfile(filename, create):
    """
    Security wrapper for openfile(filename, create).
    """
    # If user attempts to create an explicit version filename, reject
    if create and is_explicit_version(filename):
        raise RepyArgumentError("Cannot create explicit version files")

    # If the filename is an explicit version name
    base, num = parse_versioned(filename)
    if base is not None:
        # Does base exist in our versions map?
        if base not in versions:
            raise FileNotFoundError(filename)

        # Verify that the requested numbered version exists in versions[base]
        expected_name = base + ".v" + str(num)
        if expected_name not in versions[base]:
            raise FileNotFoundError(filename)

        # Check if underlying file already open
        if expected_name in open_handles:
            raise FileInUseError("File is already in use")

        # Call underlying openfile on the version name
        underlying = openfile(expected_name, False)
        # Register open handle
        open_handles[expected_name] = underlying
        # Return secured object
        return VMFile(expected_name, underlying, base, True)

    # Otherwise filename is a base name
    base = filename

    if create:
        if base not in versions:
            # No file exists at all. Create the base file directly
            underlying = openfile(base, True)
            # Register versions list
            versions[base] = [base]
            open_handles[base] = underlying
            return VMFile(base, underlying, base, False)
        else:
            # File exists already, so create a new version
            latest = latest_version_name(base)
            # Cannot create a new version if latest is currently open
            if latest in open_handles:
                raise FileInUseError("Cannot create a new version while latest version is open")

            # Create new version name
            new_name = next_version_name(base)

            # Create new underlying file
            new_underlying = openfile(new_name, True)

            try:
                src = openfile(latest, False)
                try:
                    content = src.readat(None, 0)
                    if content:
                        new_underlying.writeat(content, 0)
                finally:
                    try:
                        src.close()
                    except Exception:
                        pass
            except Exception:
                # If reading fails, close the new file and re-raise
                try:
                    new_underlying.close()
                except Exception:
                    pass
                raise

            # Register version tracking
            versions[base].append(new_name)
            open_handles[new_name] = new_underlying
            return VMFile(new_name, new_underlying, base, False)
    else:
        # create == False: open existing base (non-versioned) only if it exists
        if base not in versions:
            raise FileNotFoundError(base)
        # Open the base if exists
        if base in open_handles:
            raise FileInUseError("File is already in use")
        underlying = openfile(base, False)
        open_handles[base] = underlying
        return VMFile(base, underlying, base, False)

def LPremovefile(filename):
    # File deletion is forbidden
    raise RepyArgumentError("removefile is not allowed by versioning monitor")

def LPlistfiles():
    # Should not show versioned filenames. List only base filenames
    # Return the list of base filenames created so far
    return list(versions.keys())


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()