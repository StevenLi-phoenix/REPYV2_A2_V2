"""
Immutable and Versioned File Security Layer for RepyV2
------------------------------------------------------
Implements:
    - Automatic versioning (.v1, .v2, ...)
    - Immutability (no writes to closed or old versions)
    - No file deletions
    - Hidden version files in listfiles()
"""

TYPE = "type"
ARGS = "args"
RETURN = "return"
EXCP = "exceptions"
TARGET = "target"
FUNC = "func"
OBJC = "objc"

_open_files = set()

def _mark_open(filename):
    if filename in _open_files:
        raise FileInUseError("File is already open: " + filename)
    _open_files.add(filename)

def _mark_closed(filename):
    _open_files.discard(filename)

def _is_numeric_version(filename):
    """Return True if filename ends with .vNUM where NUM is digits"""
    parts = filename.rsplit(".v", 1)
    return len(parts) == 2 and parts[1].isdigit()

class VMFile():
    def __init__(self, filename, create):
        self.filename = filename
        self.closed = False
        self._actual_name = None
        self.immutable = False

        if create:

            # Prevent manual creation of version files like 'file.v2'
            if ".v" in filename:
                parts = filename.rsplit(".v", 1)
                if len(parts) == 2:
                    suffix = parts[1]
                    if suffix.isdigit() or (suffix.endswith('.') and suffix[:-1].isdigit()):
                        raise RepyArgumentError("Cannot create explicit version files")

            # If the base file exists → create a new version
            if filename in listfiles():
                latest_version = self._get_latest_version_num(filename)
                latest_version_name = self._get_latest_version_name(filename)

                if latest_version_name in _open_files:
                    raise FileInUseError("Cannot create new version while latest version is open")

                new_version_name = filename + ".v" + str(latest_version + 1)

                # Copy content from latest version to new version
                prev_file = openfile(latest_version_name, False)
                content = prev_file.readat(None, 0)
                prev_file.close()

                self.VMfile = openfile(new_version_name, True)
                self.VMfile.writeat(content, 0)
                self._actual_name = new_version_name
                _mark_open(new_version_name)

            else:
                # File doesn't exist → create new base file
                self.VMfile = openfile(filename, True)
                self._actual_name = filename
                _mark_open(filename)
        else:
            if filename not in listfiles():
                raise FileNotFoundError("File not found: " + filename)

            if filename in _open_files:
                raise FileInUseError("File is already open: " + filename)

            # Open existing version normally
            self.VMfile = openfile(filename, False)
            self._actual_name = filename
            _mark_open(filename)

            # All files are immutable
            self.immutable = True


    def _get_latest_version_num(self, filename):
        """Return highest version number for given filename"""
        all_files = listfiles()
        max_v = 0
        for f in all_files:
            if f.startswith(filename + ".v") and _is_numeric_version(f):
                vnum = int(f.rsplit(".v", 1)[1])
                if vnum > max_v:
                    max_v = vnum
        return max_v

    def _get_latest_version_name(self, filename):
        """Return the filename of the latest version"""
        vnum = self._get_latest_version_num(filename)
        if vnum == 0:
            return filename
        return filename + ".v" + str(vnum)

    def readat(self, num_bytes, offset):
        return self.VMfile.readat(num_bytes, offset)

    def writeat(self, data, offset):
        try:
            immutable_flag = self.immutable
        except AttributeError:
            immutable_flag = False

        if immutable_flag:
            raise FileInUseError("Cannot write to immutable file or old version")
        if self.closed:
            raise FileInUseError("Cannot write to closed file")
        return self.VMfile.writeat(data, offset)

    def close(self):
        if not self.closed:
            self.closed = True
            try:
                self.VMfile.close()
            finally:
                if self._actual_name:
                    _mark_closed(self._actual_name)
                    self._actual_name = None


def LPopenfile(filename, create):
    return VMFile(filename, create)


def LPremovefile(filename):
    # File deletion is forbidden
    raise RepyArgumentError("File deletion not allowed (immutable storage)")


def LPlistfiles():
    # Hide numeric versioned files (e.g., file.v1, file.v2)
    files = listfiles()
    base_files = set()
    for f in files:
        if _is_numeric_version(f):
            # Only hide numeric versions
            base_name = f.rsplit(".v", 1)[0]
            base_files.add(base_name)
        else:
            # Keep everything else (including base files with .v in name)
            base_files.add(f)
    return list(base_files)


# The code below sets up type checking and variable hiding for you.
# You should not change anything below this point.
sec_file_def = {
    "obj-type": VMFile,
    "name": "VMFile",
    "writeat": {"type": "func", "args": (str, (int, long)), "exceptions": Exception, "return": (int, type(None)), "target": VMFile.writeat},
    "readat": {"type": "func", "args": ((int, long, type(None)), (int, long)), "exceptions": Exception, "return": str, "target": VMFile.readat},
    "close": {"type": "func", "args": None, "exceptions": Exception, "return": (bool, type(None)), "target": VMFile.close}
}

CHILD_CONTEXT_DEF["openfile"] = {
    TYPE: OBJC,
    ARGS: (str, bool),
    EXCP: Exception,
    RETURN: sec_file_def,
    TARGET: LPopenfile
}

CHILD_CONTEXT_DEF["removefile"] = {
    TYPE: FUNC,
    ARGS: (str,),
    EXCP: Exception,
    RETURN: type(None),
    TARGET: LPremovefile
}

CHILD_CONTEXT_DEF["listfiles"] = {
    TYPE: FUNC,
    ARGS: None,
    EXCP: Exception,
    RETURN: list,
    TARGET: LPlistfiles
}

# Execute the user code
secure_dispatch_module()
